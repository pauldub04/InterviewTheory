<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>InterviewTheory</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="lectures/theory.html"><strong aria-hidden="true">1.</strong> Лекции</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">InterviewTheory</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/pauldub04/InterviewTheory" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#Курс-лекций-по-программированию-на-c-МФТИ-ФПМИ-2023-24-учебный-год-1-курс-продвинутый-поток" id="Курс-лекций-по-программированию-на-c-МФТИ-ФПМИ-2023-24-учебный-год-1-курс-продвинутый-поток">Курс лекций по программированию на C++ МФТИ ФПМИ 2023-24 учебный год, 1 курс, продвинутый поток.</a></h2>
<p><a href="https://www.youtube.com/playlist?list=PLmSYEYYGhnBviRYhIDty-CSTDS16a3whl">Плейлист</a></p>
<h1><a class="header" href="#Лекция-1" id="Лекция-1">Лекция 1</a></h1>
<ul>
<li>общие слова о C и C++</li>
<li>статическая и динамическая типизация</li>
<li>основные типы данных и операции над ними</li>
</ul>
<h1><a class="header" href="#Лекция-2" id="Лекция-2">Лекция 2</a></h1>
<h2><a class="header" href="#Неявные-преобразования-типов" id="Неявные-преобразования-типов">Неявные преобразования типов</a></h2>
<ul>
<li>integer promotions (повышают диапозон значений)</li>
</ul>
<pre><code class="language-cpp">char + int = int
int + long long = long long
// !но
int + unsigned int = unsigned int
</code></pre>
<ul>
<li>floating point promotions (так же)</li>
<li>bool &lt;- int</li>
<li>int &lt;-&gt; float (-&gt; с отбрасываеним дробной части)</li>
</ul>
<h1><a class="header" href="#Лекция-3" id="Лекция-3">Лекция 3</a></h1>
<h2><a class="header" href="#Области-видимости" id="Области-видимости">Области видимости</a></h2>
<ul>
<li>scope - фигурные скобки, также есть один глобальный scope</li>
</ul>
<pre><code class="language-cpp">namespace N {
    int x;
}

int main() {
    std::cout &lt;&lt; N::x;
    using N::x; // притащили x в наш scope
    std::cout &lt;&lt; x;
}

using namespace N; // притащили глобально весь namespace
</code></pre>
<ul>
<li>ODR (one definition rule)<br />
Каждая использумая сущность в программе должна быть 1 раз определена. Но объявлять можно сколько угодно раз. Класс можно определить несколько раз, если все определения дословно идентичны.</li>
</ul>
<pre><code class="language-cpp">// объявление - сколько угодно
void f(int x);
void f(int x);

// определение - только 1
void f(int x) {
    //...
}
</code></pre>
<ul>
<li>перегрузка функций (function overloading)</li>
</ul>
<pre><code class="language-cpp">int f();
int f(int x);
int f(double x);
// должны отличаться принимаемые типы!
</code></pre>
<ul>
<li>
<p>statements
<img src="lectures/img/0.png" alt="statements" /></p>
</li>
<li>
<p>логические операторы</p>
<ul>
<li>ленивые вычисления</li>
<li>branch prediction
<img src="lectures/img/1.png" alt="про if else" /></li>
</ul>
</li>
<li>
<p>lvalue, rvalue<br />
в самом простом приближении (на самом деле всё сложнее):<br />
lvalue - ему можно что-то присвоить<br />
rvalue - нельзя</p>
</li>
</ul>
<h1><a class="header" href="#Лекция-4" id="Лекция-4">Лекция 4</a></h1>
<h2><a class="header" href="#Выражения-и-операторы" id="Выражения-и-операторы">Выражения и операторы</a></h2>
<ul>
<li>лево и право ассоциативные</li>
<li><a href="https://en.cppreference.com/w/cpp/language/operator_precedence">приоритет операторов</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/eval_order">order of evaluation</a></li>
<li>sequenced before rules</li>
</ul>
<h1><a class="header" href="#Лекция-5" id="Лекция-5">Лекция 5</a></h1>
<h2><a class="header" href="#Ошибки" id="Ошибки">Ошибки</a></h2>
<ul>
<li>compilation errors</li>
<li>лексические ошибки</li>
<li>синтаксические ошибки</li>
<li>семантические ошибки</li>
<li>runtime error</li>
<li>undefined behaviour (большая беда языка)</li>
<li>the as-if rule (компилятор имеет право как угодно менять действия нашей программы, только чтобы наблюдаемое поведение корректной программы оставалось таким же)</li>
<li>warinings</li>
</ul>
<h1><a class="header" href="#Лекция-6" id="Лекция-6">Лекция 6</a></h1>
<h2><a class="header" href="#Указатели" id="Указатели">Указатели</a></h2>
<ul>
<li><code>*</code> и <code>&amp;</code></li>
</ul>
<pre><code class="language-cpp">int x = 10;
int* p = &amp;x;
std::cout &lt;&lt; *p;

void* vp = &amp;x;
// (для приведения типов)
</code></pre>
<ul>
<li><code>nullptr</code></li>
</ul>
<pre><code class="language-cpp">NULL // in C
nullptr // in C++
</code></pre>
<p><img src="lectures/img/2.png" alt="nullptr" /></p>
<h1><a class="header" href="#Лекция-7" id="Лекция-7">Лекция 7</a></h1>
<h2><a class="header" href="#Память" id="Память">Память</a></h2>
<ul>
<li>статическая</li>
<li>динамическая</li>
<li>автоматическая</li>
<li>стек: примерно 8мб</li>
</ul>
<p><img src="lectures/img/4.png" alt="memory" /></p>
<p>на самом деле вот так:
<img src="lectures/img/3.png" alt="memory" /></p>
<ul>
<li>static<br />
проинициализируется, когда в 1 раз зайдем в функцию</li>
</ul>
<pre><code class="language-cpp">void f() {
    static int x = 0; // тоже в статической памяти
    //...
}
</code></pre>
<ul>
<li>динамическая память<br />
операторы <code>new</code>, <code>delete</code></li>
</ul>
<pre><code class="language-cpp">int* p = new int;
delete p;

int* pa = new int[1000];
delete[] pa;
</code></pre>
<h1><a class="header" href="#Лекция-8" id="Лекция-8">Лекция 8</a></h1>
<h2><a class="header" href="#Массивы" id="Массивы">Массивы</a></h2>
<pre><code class="language-cpp">int a[10];
int b[3] = {1, 2, 3};
int c[] = {1, 2, 3}; // можно не указывать размер
int d[5] = {}; // заполнятся нулями
int* e[10]; //  массив из 10 указателей на int
int (*f)[10]; // указатель на массив из 10 int
</code></pre>
<ul>
<li>указатели на функцию<br />
function to pointer conversion</li>
</ul>
<pre><code class="language-cpp">bool cmp(int x, int y) {
    return x &lt; y;
}

int main() {
    // можно не писать &amp;, можно просто указать название функции
    bool (*p) (int, int) = &amp;cmp; 
    std::cout &lt;&lt; (void*)p;
}
</code></pre>
<p>как читать указатели? (начало лекции 9)<br />
идем вправо, потом влево. затем поднимаемся на уровень выше. и повторяем</p>
<pre><code class="language-cpp">void (*pf)(int); // указатель на функцию, которая принимает int, а возвращает void
// 0) начинаем с названия, pf это:
// 1) -&gt; пусто; &lt;- указатель
// 2) ^
// 3) -&gt; на фукнцию, которая принимает int; &lt;- а возвращает void
</code></pre>
<p>если справа видим круглые скобки, то это функция<br />
например, в шаге 3) <code>(int)</code></p>
<pre><code class="language-cpp">void (*pfa[10])(int); // массив из 10 указателей на функцию, которая принимает int, а возвращает void 
// 0) начинаем с названия, pfa это:
// 1) -&gt; массив из 10; &lt;- указателей
// 2) ^
// 3) -&gt; на фукнцию, которая принимает int; &lt;- а возвращает void
</code></pre>
<pre><code class="language-cpp">void (*(*pff[10])(int))(int); // массив из  10 указателей на функцию, которая принимает int, а возвращает указатель на другую функцию, которая принимает int, а возвращает void 

// 0) начинаем с названия, pff это:
// 1) -&gt; массив из 10; &lt;- указателей
// 2) ^
// 3) -&gt; на фукнцию, которая принимает int; &lt;- а возвращает указатель
// 4) ^
// 5) -&gt; на фукнцию, которая принимает int; &lt;- а возвращает void
</code></pre>
<p><a href="http://www.unixwiz.net/techtips/reading-cdecl.html">полезная ссылка</a></p>
<ul>
<li>аргументы по умолчанию<br />
только последние</li>
</ul>
<pre><code class="language-cpp">void point(int x = 3, int y = 4) {}
</code></pre>
<ul>
<li>variadic functions (легаси)<br />
любое число аргументов</li>
</ul>
<pre><code class="language-cpp">void simple_printf(const char* fmt...) {}
</code></pre>
<h1><a class="header" href="#Лекция-9" id="Лекция-9">Лекция 9</a></h1>
<h2><a class="header" href="#Ссылки-references" id="Ссылки-references">Ссылки (references)</a></h2>
<ul>
<li>амперсанд после типа</li>
<li>можно считать, что это новое имя старого объекта</li>
<li>на низком уровне реализуется через указатель, но не всегда</li>
</ul>
<pre><code class="language-cpp">int x = 5;
int&amp; y = x; // ссылка на x
int&amp; t = y; // тоже ссылка на x, нет ссылки на ссылку
sizeof(y); // = sizeof(x)
&amp;y; // = &amp;x
int&amp; r; // нельзя без инициализации
</code></pre>
<ul>
<li><code>error: call of overloaded ‘f(int&amp;)’ is ambiguous</code>. не можем различить, вызываться от оригинального объекта, или от ссылки</li>
</ul>
<pre><code class="language-cpp">void f(int&amp; y) {
    ++y;
}
void f(int x) {
    ++x;
}
int main() {
    int x = 5;
    int&amp; y = x;
    f(y);
    f(x);
}
</code></pre>
<ul>
<li>ссылку нельзя проинициализировать через rvalue</li>
<li>формально говоря <code>++x</code> возвращает <code>int&amp;</code>, также и с разыменованием указателя <code>*p</code> (в си это не так, там нет такого понятия. но в плюсах можно думать об этом так)</li>
<li>lvalue to rvalue conversion</li>
</ul>
<pre><code class="language-cpp">int&amp; g(int&amp; x) {/*...*/}
int main() {
    int x = 10;
    int t = g(x); // g(x) - lvalue, но используем как rvalue 
}
</code></pre>
<ul>
<li>
<p>нельзя путать (ну это skill issue)<br />
<img src="lectures/img/5.png" alt="прикол" /><br />
и нельзя путать с <code>int&amp;&amp;</code> (rvalue-ссылка)</p>
</li>
<li>
<p>dangling reference<br />
возвращаем ссылку, но такого объекта уже нет</p>
</li>
</ul>
<pre><code class="language-cpp">int&amp; f(int&amp; x) {
    int y = ++x;
    return y;
}
int main() {
    int x = 0;
    int&amp; y = f(x); // UB
}
</code></pre>
<ul>
<li>static (аналогично глобальные переменные)</li>
</ul>
<pre><code class="language-cpp">int&amp; f() {
    static int y = 0;
    return y; // y существует всё время работы программы
}
int main() {
    int&amp; y = f(); // OK
}
</code></pre>
<ul>
<li>указатель (шок контент)</li>
</ul>
<pre><code class="language-cpp">int&amp; f() {
    int* p = new int(1);
    return *p;
}
int main() {
    int&amp; x = f();
    delete &amp;x; // OK
}
</code></pre>
<ul>
<li>можно:
<ul>
<li>ссылка на указатель</li>
<li>ссылка на массив</li>
</ul>
<pre><code class="language-cpp">int a[10];
int (&amp;b)[10] = a;
// читается так же, как в прошлой лекции
</code></pre>
<ul>
<li>ссылка на функцию</li>
</ul>
<pre><code class="language-cpp">void f(int);
void (&amp;g)(int) = f;
</code></pre>
</li>
<li>нельзя:
<ul>
<li>указатель на ссылку (нет такого типа. но можно создать указатель на исходный объект)</li>
<li>массив ссылок</li>
<li>вектор ссылок (т.к. там указатель на <code>T</code>)</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#Лекция-10" id="Лекция-10">Лекция 10</a></h1>
<h2><a class="header" href="#Константы" id="Константы">Константы</a></h2>
<ul>
<li>интуиция: другой тип, у которого отсутствует часть операций исходного типа (модифицирующих)</li>
</ul>
<pre><code class="language-cpp">const int c = 2;
с = 2; // CE
int const a = 10; // можно писать const справа
</code></pre>
<ul>
<li>указатели</li>
</ul>
<pre><code class="language-cpp">int x = 5;
int* p = &amp;x;

const int* pc = p; // указатель на const int
int* const cp = p; // const указатель на int 
const int* const cpc = p; // const указатель на const int
</code></pre>
<ul>
<li>неявное преобразование константности <code>int* -&gt; const int*</code>. в обратную сторону нельзя.<br />
но это всего лишь запрет на некоторые операции, а не запрет, что объект не поменяется.</li>
</ul>
<pre><code class="language-cpp">int x = 5;
const int* p = &amp;x;
++x;
std::cout &lt;&lt; *p; // увидим новое значение
</code></pre>
<ul>
<li>аналогично, ссылки</li>
</ul>
<pre><code class="language-cpp">int x = 5;
const int&amp; r = x; // новое название для x, с ограниченными правами
int&amp; const rc = x; // CE. ссылка сама по себе не может быть переставлена на что-то другое, по этому не бывает константных ссылок
</code></pre>
<ul>
<li>константные ссылки (в смысле ссылка на const объект), (используются для передачи аргументов, если не собираемся менять объект).<br />
!!! Lifetime expansion: обычные ссылки инициализировать через rvalue нельзя, а константные можно. Создаётся временный объект. Компилятор считает это имя оригинальным именем объекта. Когда эта ссылка выйдет из области видимости, тогда объект уничтожится.</li>
</ul>
<pre><code class="language-cpp">void f(const std::string&amp; s) {/*...*/}

int main() {
    f(&quot;asdf&quot;); // OK
    const int&amp; x = 5; // тоже OK
}
</code></pre>
<p><a href="https://isocpp.org/wiki/faq/const-correctness">советы про const</a></p>
<h1><a class="header" href="#Лекция-11" id="Лекция-11">Лекция 11</a></h1>
<h2><a class="header" href="#a-hreflecturescastingtheoryhtmlПриведения-типовa" id="a-hreflecturescastingtheoryhtmlПриведения-типовa"><a href="lectures/../casting/theory.html">Приведения типов</a></a></h2>
<h2><a class="header" href="#Стадии-сборки" id="Стадии-сборки">Стадии сборки</a></h2>
<ol>
<li>препроцессинг
<ul>
<li>директивы <code>#include</code>, <code>#define</code>, <code>#if</code>, <code>#pragma</code>, ...</li>
<li><code>.cpp -&gt; .cpp</code>, но без директив</li>
</ul>
</li>
<li>комплиция
<ul>
<li>получаем ассемблер код</li>
<li><code>.cpp -&gt; .s</code></li>
</ul>
</li>
<li>ассемблирование
<ul>
<li>получаем объектный файл с бинарным кодом</li>
<li><code>.s -&gt; .o</code> (или динамические <code>.so</code>, <code>.dll</code>)</li>
</ul>
</li>
<li>линковка
<ul>
<li>собирает объектные файлы в исполняемый файл</li>
<li>резолвим вызовы всех функций</li>
<li><code>.o -&gt; executable</code></li>
</ul>
</li>
</ol>
<h1><a class="header" href="#Лекция-12" id="Лекция-12">Лекция 12</a></h1>
<h2><a class="header" href="#ООП" id="ООП">ООП</a></h2>
<ul>
<li>выравнивание полей<br />
1-байтные переменные кладутся по адресам, кратным 1<br />
2-байтные переменные кладутся по адресам, кратным 2<br />
4-байтные переменные кладутся по адресам, кратным 4<br />
8-байтные переменные кладутся по адресам, кратным 8<br />
<img src="lectures/img/6.png" alt="alignment" /></li>
</ul>
<p>The alignment of the struct is the alignment of the most-aligned field in it</p>
<pre><code class="language-cpp">struct S {
    int x = 1;
    double d = 3.14;
};
// 16 байт (4 int, 4 padding, 8 double)
</code></pre>
<ul>
<li>гарантируется порядок полей в структуре</li>
<li>аггрегатная инициализация</li>
</ul>
<pre><code class="language-cpp">struct S {
    int x = 1;
    double d = 3.14;
};
int main() {
    S s{2, 4.5};
}
</code></pre>
<p>можно с именами, но в таком же порядке!</p>
<pre><code class="language-cpp">struct xyz {
    int a;
    int b;
    int c;
};
int main() {
    xyz klm = { .a = 99, .c = 100 };
}
</code></pre>
<ul>
<li>методы</li>
</ul>
<pre><code class="language-cpp">struct S {
    void f(int x);
    void g(int y) {
        //...
    }
};
void S::f(int x) {/*...*/} // qualified id
</code></pre>
<ul>
<li>
<p>this - указатель на объект<br />
<code>-&gt;</code> обращение к полю/методу по указателю</p>
</li>
<li>
<p>inner class</p>
</li>
</ul>
<pre><code class="language-cpp">struct A {
    int x = 1;
    double d = 3.14;
    struct AA {
        char c;
    };
};
int main() {
    A::AA a;
}
</code></pre>
<pre><code class="language-cpp">struct A {
    int x = 1;
    double d = 3.14;
    struct AA { // можно даже без названия - анонимная структура
        char c;
    } a;
};
int main() {
    A::AA a;
}
</code></pre>
<ul>
<li>local class</li>
</ul>
<pre><code class="language-cpp">int main() {
    struct S {
        int x = 1;
        int y = 2;
    };
    S s;
}
</code></pre>
<h2><a class="header" href="#Модификаторы-доступа" id="Модификаторы-доступа">Модификаторы доступа</a></h2>
<ul>
<li>классы и структуры<br />
в плюсах почти нет разницы. в структуре по умолчанию всё публичное, в классе приватное</li>
</ul>
<pre><code class="language-cpp">class C {
    int x;
};
int main() {
    C c;
    c.x; // CE
}
</code></pre>
<ul>
<li>public, private<br />
к private можем обращаться только внутри методов</li>
<li>protected обсудим позже</li>
<li>!! приватность проверяется после перегрузки</li>
</ul>
<h1><a class="header" href="#Лекция-13" id="Лекция-13">Лекция 13</a></h1>
<h2><a class="header" href="#Друзья" id="Друзья">Друзья</a></h2>
<ul>
<li>функции или классы, которые не являются членами нашего класса, но им разрешен доступ к приватной части<br />
объявляем через friend в любом месте внутри класса (определить можно и внутри, и снаружи)</li>
</ul>
<pre><code class="language-cpp">class C {
private:
    int x{5};
    friend void g(C, int);
    friend class CC; // все методы этого класса будут друзьями
};

void g(C c, int y) {
    std::cout &lt;&lt; c.x + y &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h2><a class="header" href="#Конструкторы" id="Конструкторы">Конструкторы</a></h2>
<pre><code class="language-cpp">class Complex {
    double re = 0.0;
    double im = 0.0;
public:
    Complex (double real) {
        re = real;
    }
};
int main() {
    // здесь 4 раза вызывается одинаковый конструктор
    Complex c(5.0);
    Complex c2 = 6.0;
    // если есть хоть 1 конструктор, то аггрегатная инициализация перестаёт работать
    Complex c3{7.0};
    Complex c4 = {8.0};
}
</code></pre>
<ul>
<li>uniform initialization</li>
</ul>
<pre><code class="language-cpp">struct Coord { int x, y; };
struct BadGrid { BadGrid(int width, int height); };
struct GoodGrid { explicit GoodGrid(int width, int height); };
</code></pre>
<p><img src="lectures/img/7.png" alt="uniform initialization" />
<a href="https://quuxplusone.github.io/blog/2019/02/18/knightmare-of-initialization/">статья 1</a>
<a href="https://quuxplusone.github.io/blog/2022/06/03/aggregate-parens-init-considered-kinda-bad/">статья 2</a></p>
<ul>
<li>member initializer list</li>
</ul>
<pre><code class="language-cpp">class Complex {
    double re = 0.0;
    double im = 0.0;
public:
    // re не проинициализируется 0 по умолчанию
    // это выполнится перед конструктором
    Complex (double re) : re(re) {}
    Complex (double re, double im) : re(re), im(im) {} // желательно писать в таком же порядке
};
</code></pre>
<ul>
<li>std::initializer_list (C++11)</li>
</ul>
<pre><code class="language-cpp">class String {
    char* arr = nullptr;
    size_t sz = 0;
    size_t cap = 0;
public:
    String() {} // default constructor
    
    String(size_t n, char c) : arr(new char[n+1]), sz(n), cap(n+1) {
        std::fill(arr, arr+n, c);
        arr[sz] = '\0';
    }

    String(std::initializer_list&lt;char&gt; list)
        : arr(new char[list.size()])
        , sz(list.size())
        , cap(sz+1)
    {
        std::copy(list.begin(), list.end(), arr);
        arr[sz] = '\0';
    }
};

int main() {
    String s; // default initialization
    String s2 = {'a', 'b', 'c'};
    String s3 = {2, 'b'}; // тоже вызовется от std::initializer_list
    // !! но если бы его не было, вызвался бы String(size_t n, char c)
}
</code></pre>
<ul>
<li>если не объявили конструкторы, то компилятор сгенерирует сам конструктор по умолчанию (он будет просто инциализировать поля по умолчанию). Если объявили хоть один конструктор, то комплиятор не будет этого делать. Но можно попросить (C++11)</li>
</ul>
<pre><code class="language-cpp">class String {
    char* arr = nullptr;
    size_t sz = 0;
    size_t cap = 0;
public:
    String() = default; // explicitly declared, implicitly defined
    
    String(size_t n, char c) : arr(new char[n+1]), sz(n), cap(n+1) {
        memset(arr, c, n);
        // std::fill(arr, arr+n, c);
        arr[sz] = '\0';
    }
};
</code></pre>
<ul>
<li>или можно запретить генерировать (C++11)</li>
</ul>
<pre><code class="language-cpp">class C {
//...
    C() = delete;
};
</code></pre>
<ul>
<li>но не всегда может сгенерироваться конструктор по умолчанию</li>
</ul>
<pre><code class="language-cpp">class C {
    // не знаем как проинициализировать по умолчанию
    int&amp; r;
    const int c;
};
</code></pre>
<h2><a class="header" href="#Деструкторы" id="Деструкторы">Деструкторы</a></h2>
<ul>
<li>вызываются в обратном порядке констуркторам (как стек). Сначала выполняется код деструктора нашего класса, а потом его полей.</li>
</ul>
<pre><code class="language-cpp">~String() {
    delete[] arr;
}
</code></pre>
<h2><a class="header" href="#Конструктор-копирования" id="Конструктор-копирования">Конструктор копирования</a></h2>
<ul>
<li>генерируется по умолчанию (просто копирует поля). Причем даже если есть и другие конструкторы</li>
<li>константная ссылка, хотя можно и без const</li>
<li>так же лучше делать с member initializer list</li>
</ul>
<pre><code class="language-cpp">String(const String&amp; other)
    : arr(new char[other.cap])
    , sz(other.sz)
    , cap(other.cap)
{
    memcpy(arr, other.arr, sz+1);
}

int main() {
    String s(2, 'a');
    String s2 = s; // конструктор копирования

    String s3 = s3; // UB
}
</code></pre>
<h2><a class="header" href="#Делегирующие-конструкторы-c11" id="Делегирующие-конструкторы-c11">Делегирующие конструкторы (C++11)</a></h2>
<ul>
<li>вызываем только 1 конструктор и нельзя использовать member initializer list</li>
</ul>
<pre><code class="language-cpp">class String {
    char* arr = nullptr;
    size_t sz = 0;
    size_t cap = 0;

    String(size_t n, char c) : arr(new char[n+1]), sz(n), cap(n+1) {
        arr[sz] = '\0';
    }
public:
    String() = default;

    String(size_t n, char c) : String(n) {
        memset(arr, c, n);
    }
    String(std::initializer_list&lt;char&gt; list) : String(list.size()) {
        std::copy(list.begin(), list.end(), arr);
    }
    String(const String&amp; other) : String(other.sz) {
        memcpy(arr, other.arr, sz+1);
    }
};
</code></pre>
<h2><a class="header" href="#Оператор-присваивания" id="Оператор-присваивания">Оператор присваивания</a></h2>
<pre><code class="language-cpp">String&amp; operator=(const String&amp; other) {
    if (this == other) { // в таком случае обязательно надо проверять!
        return *this;
    }
    delete[] arr;
    sz = other.sz;
    cap = other.cap;
    arr = new char[other.cap];
    memcpy(arr, other.arr, sz+1);
    return *this;
}
</code></pre>
<ul>
<li>тоже можно попросить сгенерировать (но тоже не всегда получится)</li>
<li>идиома copy and swap</li>
</ul>
<pre><code class="language-cpp">void swap(String &amp;other) {
    std::swap(arr, other.arr);
    std::swap(sz, other.sz);
    std::swap(cap, other.cap);
}
String&amp; operator=(const String&amp; other) {
    String copy = other; // конструктор копирования
    swap(copy);
    return *this;
}
</code></pre>
<p>еще проще можно сделать так</p>
<pre><code class="language-cpp">String&amp; operator=(String other) { // конструктор копирования при вызове
    swap(other);
    return *this;
}
</code></pre>
<p>в таких случаях можно не делать проверку на присваивание самому себе</p>
<h2><a class="header" href="#Правило-трех" id="Правило-трех">Правило трех</a></h2>
<p>Реккомендация по написанию классов: Если в классе есть нетривиальный конструктор копирования, или нетривиальный оператор присваивания, или нетривиальный деструктор, то нужно чтобы все 3 они были нами написаны.</p>
<h1><a class="header" href="#Лекция-15" id="Лекция-15">Лекция 15</a></h1>
<h2><a class="header" href="#const-mutable" id="const-mutable">Const, mutable</a></h2>
<ul>
<li>отсутствуют методы, которые явно не помечены, что должны присустствовать у константных объектов</li>
</ul>
<pre><code class="language-cpp">struct S {
    void f() {
        std::cout &lt;&lt; &quot;Hi!&quot;;
    }
};
int main() {
    const S s;
    s.f(); // CE
}
</code></pre>
<pre><code class="language-cpp">struct S {
    void f() const {
        std::cout &lt;&lt; &quot;Hi!&quot;;
    }
};
int main() {
    const S s;
    s.f(); // OK
}
</code></pre>
<p>вывод: все методы, которые, предполагается, что будут вызваны у константных объектов, надо помечать const</p>
<ul>
<li>
<p>не имеет никакого отношения к конструкторам и деструкторам</p>
</li>
<li>
<p>в const методах нельзя вызывать неконстантные операции у полей</p>
</li>
</ul>
<pre><code class="language-cpp">struct S {
    int x = 0;
    void f() const {
        ++x; // CE
        std::cout &lt;&lt; &quot;Hi!&quot;;
    }
};
</code></pre>
<ul>
<li>перегрузка</li>
</ul>
<pre><code class="language-cpp">struct S {
    void f() const {
        std::cout &lt;&lt; 1;
    }
    void f() {
        std::cout &lt;&lt; 2;
    }
};
</code></pre>
<ul>
<li>компилятор неявно навешивает const на все поля. Если это указатель, то он неявно превращается в const указатель (но не указатель на const!), то есть как будто появляется const справа. Однако на ссылку нельзя навесить const справа (подразумевается, что неизменными должны быть сами байты, которые кодируют ссылку, но не объект, на который она указывает). Поэтому для ссылок нет разницы между константным методом и обычным</li>
</ul>
<pre><code class="language-cpp">int x = 0;
struct S {
    int&amp; r = x;
    void f(int y) const {
        r = y; // OK
    }
};
</code></pre>
<p>поэтому вот такой прикол</p>
<pre><code class="language-cpp">struct S {
    int x = 1;
    int&amp; r = x;
    void f(int y) const {
        r = y; // поменяет x в const методе
    }
};
</code></pre>
<ul>
<li>mutable (противоядие от const)</li>
</ul>
<pre><code class="language-cpp">struct S {
    mutable int x = 1;
    void f(int y) const {
       x = y;
    }
};
</code></pre>
<h2><a class="header" href="#static" id="static">Static</a></h2>
<pre><code class="language-cpp">struct S {
    static void f() {
        std::cout &lt;&lt; &quot;Hi!&quot;;
    }
};
int main() {
    S::f();
}
</code></pre>
<ul>
<li>нельзя внутри класса инициализировать неконстантные статические члены, но const можно</li>
</ul>
<pre><code class="language-cpp">struct S {
    static int x = 10; // CE
    const static int y = 5; // OK
};
int S::x = 1; // OK
</code></pre>
<ul>
<li>singleton </li>
</ul>
<pre><code class="language-cpp">struct Singleton {
private:
    Singleton() {}
    static Singleton* ptr;

    Singleton(const Singleton&amp;) = delete;
    Signleton&amp; operator=(const Singleton&amp;) = delete;
public:
    static Singleton&amp; getObject() {
        if (ptr == nullptr) {
            ptr = new Singleton();
        }
        return *ptr;
    }
    // добавить деструктор
};
Singleton* Singleton::ptr = nullptr;

int main() {
    Singleton&amp; s = Singleton::getObject();
}
</code></pre>
<h2><a class="header" href="#Приведение-типов" id="Приведение-типов">Приведение типов</a></h2>
<ul>
<li>explicit запрещает неявную конверсию<br />
по кодстайлу рекомендуется делать так для конструкторов одного аргумента</li>
</ul>
<pre><code class="language-cpp">struct Latitude {
    double value;
    explicit Latitude(double value) : value(value) {}
};
</code></pre>
<p>также с aggregate initialization</p>
<pre><code class="language-cpp">struct BadGrid {
    BadGrid(int width, int height);
};
struct GoodGrid {
    explicit GoodGrid(int width, int height);
};
int main() {
    BadGrid g1 = {10, 20}; // OK
    GoodGrid g2 = {10, 20}; // CE
}

</code></pre>
<ul>
<li>приведение типа к чему-то</li>
</ul>
<pre><code class="language-cpp">struct Latitude {
    double value;
    explicit Latitude(double value) : value(value) {}
    operator double() const { // к double
        return value;
    }
};
</code></pre>
<ul>
<li>но можно запретить неявную. Остается только явная (static_cast)</li>
</ul>
<pre><code class="language-cpp">struct Latitude {
    double value;
    explicit Latitude(double value) : value(value) {}
    explicit operator double() const { // запретили неявную
        return value;
    }
};
</code></pre>
<h2><a class="header" href="#Литеральные-суффиксы" id="Литеральные-суффиксы">Литеральные суффиксы</a></h2>
<ul>
<li>их можно определять)</li>
<li><code>&quot;sdfsadf&quot;s // это std::string</code></li>
</ul>
<h1><a class="header" href="#Лекция-16" id="Лекция-16">Лекция 16</a></h1>
<h2><a class="header" href="#Перегрузка-операторов" id="Перегрузка-операторов">Перегрузка операторов</a></h2>
<pre><code class="language-cpp">struct Complex {
    double re = 0.0;
    double im = 0.0;
    Complex(double re) : re(re) {}
    Complex(double re, double im) : re(re), im(im) {}

    Complex operator+(const Complex&amp; other) const { // чтобы могли вызываться от const объектов
        return Complex(re + other.re, im + other.im);
    }
    // если определить внтури класса, то оператор не симметричный. запрещаем левому агрументу быть не объектом класса
};

int main() {
    Complex c(1.0);
    c + 3.14; // OK
    3.14 + c; // CE
}
</code></pre>
<pre><code class="language-cpp">struct Complex {
    double re = 0.0;
    double im = 0.0;
    Complex(double re) : re(re) {}
    Complex(double re, double im) : re(re), im(im) {}
};

// здесь уже без const
Complex operator+(const Complex&amp; a, const Complex&amp; b) {
    return Complex(a.re + b.re, a.im + b.im);
}

int main() {
    Complex c(1.0);
    c + 3.14; // OK
    3.14 + c; // OK
}
</code></pre>
<ul>
<li>плохая реализация</li>
</ul>
<pre><code class="language-cpp">struct Complex {
    double re = 0.0;
    double im = 0.0;
    Complex(double re) : re(re) {}
    Complex(double re, double im) : re(re), im(im) {}

    // очень медленно на больших объектах
    Complex&amp; operator+=(const Complex &amp;other) {
        // 1) новый объект *this + other
        // 2) operator=
        *this = *this + other;
        return *this;
    }
};
Complex operator+(const Complex&amp; a, const Complex&amp; b) {
    return Complex(a.re + b.re, a.im + b.im);
}
</code></pre>
<p>надо <code>+</code> выражать через <code>+=</code></p>
<pre><code class="language-cpp">struct Complex {
    double re = 0.0;
    double im = 0.0;
    Complex(double re) : re(re) {}
    Complex(double re, double im) : re(re), im(im) {}

    Complex&amp; operator+=(const Complex &amp;other) {
        re += other.re;
        im += other.im;
        return *this;
    }
};

Complex operator+(const Complex&amp; a, const Complex&amp; b) {
    Complex result = a;
    result += b;
    return result;
}

int main() {
    Complex a(1.0);
    Complex b(2.0);
    Complex c(3.0);
    // так как мы явно не запретили присваиваивание для rvalue
    a + b = c; // OK
}
</code></pre>
<p>надо фиксить так (C++11)</p>
<pre><code class="language-cpp">// применим только к lvalue
Complex&amp; operator=(const Complex &amp;other) &amp;  {/**/}
// применим только к rvalue
Complex&amp; operator=(const Complex &amp;other) &amp;&amp;  {/**/}
</code></pre>
<ul>
<li>опять про копирования<br />
если возвращаем локальную переменную по значению наружу - RVO</li>
</ul>
<pre><code class="language-cpp">Complex operator+(const Complex&amp; a, const Complex&amp; b) {
    Complex result = a; // 1) копирование
    result += b;        // 2) в зависимости от объекта
    return result;      // 3) RVO - нет копирования
}

// так не сработает, не локальная переменная
Complex operator+(Complex a, const Complex&amp; b) {
    return a += b;
}
</code></pre>
<ul>
<li>потоки вывода</li>
</ul>
<pre><code class="language-cpp">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const std::string&amp; str) {/**/}
std::istream&amp; operator&gt;&gt;(std::istream&amp; in, std::string&amp; str) {/**/}
</code></pre>
<ul>
<li>операторы сравнения</li>
</ul>
<pre><code class="language-cpp">bool operator&lt;(const Complex&amp; a, const Complex&amp; b) {
    return a.re &lt; b.re || a.re == b.re &amp;&amp; a.im &lt; b.im;
}
</code></pre>
<pre><code>a &gt; b  == b &lt; a
a &lt;= b == !(a &gt; b)
a &gt;= b == !(a &lt; b)

a == b == !(a &lt; b) &amp;&amp; !(b &lt; a)
a != b == a &lt; b || b &lt; a
// но лучше равенство определить руками
</code></pre>
<ul>
<li>operator spaceship (Three-way comparison) (C++20)<br />
partial_ordering (&lt;, &gt;, =, не сравним)<br />
weak_ordering (&lt;, &gt;, =)<br />
strong_ordering (&lt;, &gt;, =) и еще <code>a == b =&gt; f(a) == f(b)</code></li>
</ul>
<pre><code class="language-cpp">struct Complex {
    double re = 0.0;
    double im = 0.0;
    Complex(double re) : re(re) {}
    Complex(double re, double im) : re(re), im(im) {}

    // по умолчанию - лексикографически
    std::weak_ordering operator&lt;=&gt;(const Complex&amp; other) const = default;
};
</code></pre>
<pre><code class="language-cpp">struct Complex {
    double re = 0.0;
    double im = 0.0;
    Complex(double re) : re(re) {}
    Complex(double re, double im) : re(re), im(im) {}

    std::weak_ordering operator&lt;=&gt;(const Complex&amp; other) const {
        return std::weak_ordering::equivalent;
    }
    // operator== не доопределяется
};
</code></pre>
<ul>
<li>инкремент, декремент</li>
</ul>
<pre><code class="language-cpp">struct UserID {
    int value = 0;

    UserID&amp; operator++() {
        ++value;
        return *this;
    }
    UserID operator++(int) {
        UserID copy = *this;
        ++value;
        return copy;
    }
}
</code></pre>
<ul>
<li>operator()</li>
</ul>
<pre><code class="language-cpp">// функтор
struct Greater {
    bool operator() (int x, int y) {
        return x &gt; y;
    }
}
int main() {
    std::vector&lt;int&gt; v(10);
    std::sort(v.begin(), v.end(), Greater());
}
</code></pre>
<h1><a class="header" href="#Лекция-17" id="Лекция-17">Лекция 17</a></h1>
<h2><a class="header" href="#Указатель-на-члены-класса" id="Указатель-на-члены-класса">Указатель на члены класса</a></h2>
<pre><code class="language-cpp">struct S {
    int x;
    double y;

    void f(int z) {
        std::cout &lt;&lt; x + z;
    }
};

int main() {
    int S::* p = &amp;S::x; // указатель на поле класса

    S s{1, 3.14};
    S* ps = &amp;s;
    std::cout &lt;&lt; s.*p; // достанет int из объекта
    std::cout &lt;&lt; ps-&gt;*p; // то же самое, но по указателю

    void (S::* pf)(int) = &amp;S::f; // указатель на метод класса
    (s.*pf)(3);
    (s-&gt;*pf)(5);
}
</code></pre>
<h2><a class="header" href="#enums-and-enum-classes" id="enums-and-enum-classes">Enums and enum classes</a></h2>
<ul>
<li>enum</li>
</ul>
<pre><code class="language-cpp">enum E {
    White,
    Gray,
    Black
};

int main() {
    E e = White;
    int e1 = White; // OK
    std::cout &lt;&lt; e; // OK
}
</code></pre>
<ul>
<li>enum class (C++11)</li>
</ul>
<pre><code class="language-cpp">enum class E {
    White,
    Gray,
    Black
};

int main() {
    E e = E::White;
    int e1 = E::White; // CE
    std::cout &lt;&lt; e;    // CE
    // можно делать static_cast
}
</code></pre>
<ul>
<li>можно задать значения</li>
</ul>
<pre><code class="language-cpp">enum class E {
    White = 2,
    Gray = 9,
    Black= 6
};
</code></pre>
<ul>
<li>наследования</li>
</ul>
<pre><code class="language-cpp">enum class E : int8_t {
    White = 2,
    Gray = 9,
    Black= 6
};
</code></pre>
<h2><a class="header" href="#Наследования" id="Наследования">Наследования</a></h2>
<ul>
<li>public, private, protected<br />
protected член класса доступен всем другим членам класса, друзьям и всем наследникам </li>
</ul>
<pre><code class="language-cpp">struct Base {
protected:
    int x;
public:
    void f() {}
};

struct Derived : Base {
    int y;
    void g() {
        std::cout &lt;&lt; x;
    }
}

int main() {
    Derived d;
    std::cout &lt;&lt; d.x; // CE
}
</code></pre>
<ul>
<li>можно добавить модицикатор доступа при самом наследовании<br />
у классов по умолчанию родитель private, у структур public</li>
</ul>
<pre><code class="language-cpp">struct Derived : public Base {
    int y;
    void g() {
        std::cout &lt;&lt; x;
    }
}

int main() {
    Derived d;
    std::cout &lt;&lt; d.x; // CE
}
</code></pre>
<p>чтобы обратиться к полю, надо пройти через 2 двери. Надо и чтобы Derived не запрещал доступ к Base, и чтобы Base не запрещал доступ к своим полям.</p>
<ul>
<li>protected</li>
</ul>
<pre><code class="language-cpp">struct Granny {
    int x;
    void f() {}
};
struct Mom : protected Granny {
    int y;
    void g() {}
};
struct Son : Mom {
    int z;
    void h() {
        std::cout &lt;&lt; x; // OK
    }
};
int main() {
    Son s;
    s.z; // OK
    s.y(); // OK
    s.x; // CE
}
</code></pre>
<ul>
<li>видимость и доступность полей и методов<br />
частное предпочтительнее общего</li>
</ul>
<pre><code class="language-cpp">struct Base {
    void f() {
        std::cout &lt;&lt; 1;
    }
};
struct Derived : Base {
    void f() {
        std::cout &lt;&lt; 2;
    }
};
int main() {
    Derived d;
    d.f(); // 2
}
</code></pre>
<p>Это не перегрузка функций. f() затмевает родительскую функцию. Функция из Base даже не рассматривается</p>
<pre><code class="language-cpp">struct Base {
    void f(int) {
        std::cout &lt;&lt; 1;
    }
};
struct Derived : Base {
    void f(double) {
        std::cout &lt;&lt; 2;
    }
};
int main() {
    Derived d;
    d.f(0); // 2

    // но можно вызвать явно
    d.Base::f(0); // 1
}
</code></pre>
<p>тут было еще много разных душных кейсов, которые я не захотел записывать</p>
<h1><a class="header" href="#Лекция-18" id="Лекция-18">Лекция 18</a></h1>
<h2><a class="header" href="#Размещение-объектов-в-памяти" id="Размещение-объектов-в-памяти">Размещение объектов в памяти</a></h2>
<pre><code class="language-cpp">struct Base {
    int x;
};
struct Derived : Base {
    double y;
};
int main() {
    std::cout &lt;&lt; sizeof(Derived); // 16
    // 4 (int) + 4 (padding) + 8 (double)
}
</code></pre>
<ul>
<li>EBO (Empty Base Optimization)</li>
</ul>
<pre><code class="language-cpp">struct Base {
    void f() {}
};
struct Derived : Base {
    double y;
    void g() {}
};
int main() {
    std::cout &lt;&lt; sizeof(Base);    // 1
    std::cout &lt;&lt; sizeof(Derived); // 8
}
</code></pre>
<h2><a class="header" href="#Конструкторы-деструкторы-при-наследовании" id="Конструкторы-деструкторы-при-наследовании">Конструкторы, деструкторы при наследовании</a></h2>
<p>Сначала создаётся объект родителя (инциализация полей + конструтор), только потом объект наследника (инициализация полей + конструктор)</p>
<pre><code class="language-cpp">struct Base {
    int x;
    Base(int x) : x(x) {}
};
struct Derived : Base {
    int y;
    Derived(int y) : y(y) {}
};
int main() {
    Derived d = 3.14; // CE
    // нет нужного конструктора для Base
}
</code></pre>
<ul>
<li>явный вызов родительского конструктора</li>
</ul>
<pre><code class="language-cpp">struct Base {
    int x;
    Base(int x) : x(x) {}
};
struct Derived : Base {
    int y;
    Derived(int y) : Base(0), y(y) {}
};
int main() {
    Derived d = 3.14; // OK
}
</code></pre>
<ul>
<li>наследование конструкторов (C++11)</li>
</ul>
<pre><code class="language-cpp">struct Base {
    int x;
    Base(int x) : x(x) {}
};
struct Derived : Base {
    int y = 0;
    using Base::Base; // унаследовали конструктор из Base
};
</code></pre>
<p>конструкторы копирования и перемещения не наследуется</p>
<h2><a class="header" href="#Приведение-типов-при-наследовании" id="Приведение-типов-при-наследовании">Приведение типов при наследовании</a></h2>
<p>основная идея наследования</p>
<pre><code class="language-cpp">struct Base {
    int x;
};
struct Derived : Base {
    int y;
}
void f(Base&amp; b) { // смотрим на Derived, как будто он Base
    cout &lt;&lt; b.x;
}
int main() {
    Derived d;
    f(d);
}
</code></pre>
<p>аналогично для указателей</p>
<pre><code class="language-cpp">void f(Base* b) {
    cout &lt;&lt; b-&gt;x;
}
int main() {
    Derived d;
    f(&amp;d);
}
</code></pre>
<p>можно и по значению</p>
<pre><code class="language-cpp">// slicing (срезка при копировании)
// в новый объект явно скопируется та часть Base, которая внутри Derived
// вызовется нетривиальный конструктор копирования, если он есть
void f(Base b) {
    cout &lt;&lt; b.x;
}
int main() {
    Derived d;
    f(d);
}
</code></pre>
<h1><a class="header" href="#Лекция-19" id="Лекция-19">Лекция 19</a></h1>
<h2><a class="header" href="#a-hreflecturesoopinheritancetheoryhtmld0bfd180d0b8d0b2d0b5d0b4d0b5d0bdd0b8d0b5-d182d0b8d0bfd0bed0b2-d0bfd180d0b8-d0bdd0b0d181d0bbd0b5d0b4d0bed0b2d0b0d0bdd0b8d0b8Приведение-типов-при-наследованииa" id="a-hreflecturesoopinheritancetheoryhtmld0bfd180d0b8d0b2d0b5d0b4d0b5d0bdd0b8d0b5-d182d0b8d0bfd0bed0b2-d0bfd180d0b8-d0bdd0b0d181d0bbd0b5d0b4d0bed0b2d0b0d0bdd0b8d0b8Приведение-типов-при-наследованииa"><a href="lectures/../oop/inheritance/theory.html#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%BF%D1%80%D0%B8-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8">Приведение типов при наследовании</a></a></h2>
<ul>
<li>публичное наследование
<img src="lectures/img/8.png" alt="alt text" />
possibly UB - при попытке обращения к полям и методам Derived будет UB</li>
<li>приватное наследование<br />
если мы не член класса и не друг, нам недоступен тот факт, что Derived это на самом деле Base
<img src="lectures/img/9.png" alt="alt text" /></li>
</ul>
<h2><a class="header" href="#a-hreflecturesoopinheritancetheoryhtmlmultiple-inheritanceМножественное-наследованиеa" id="a-hreflecturesoopinheritancetheoryhtmlmultiple-inheritanceМножественное-наследованиеa"><a href="lectures/../oop/inheritance/theory.html#multiple-inheritance">Множественное наследование</a></a></h2>
<p><img src="lectures/img/10.png" alt="alt text" /></p>
<ul>
<li>как располагается в памяти
<img src="lectures/img/11.png" alt="alt text" /></li>
<li>как должен работать каст<br />
сын - частный случай папы. Но адрес папы не такой, как адрес сына.
Подобъект папы начинается с адреса на 4 большего, чем сам исходный объект.
<img src="lectures/img/12.png" alt="alt text" />
по этому неявный каст должен сдвинуть адрес.
Пример неявного каста одного указателя к другому, при котором численное значение адреса меняется
<img src="lectures/img/13.png" alt="alt text" /></li>
<li>если поля или методы называются одинаково
<img src="lectures/img/14.png" alt="alt text" /><br />
Если в сыне объявили метод f, то дальше поиск не пойдет, он затмевает родительские - уже разбирали.
Но если в сыне не будет метода f, то CE.
Причем если просто унаследовали 2 одинаковых метода, то ничего не будет.
Но если собираемся вызвать - уже CE.<br />
<img src="lectures/img/15.png" alt="alt text" />
Тут Мещерин сказал, что будет перегрузка. Но её нет! Но можно явно вызвать нужный метод</li>
</ul>
<pre><code class="language-cpp">s.M::f(5);
s.D::f(3.14);
</code></pre>
<h2><a class="header" href="#a-hreflecturesoopinheritancetheoryhtmldiamond-problem-d180d0bed0bcd0b1d0bed0b2d0b8d0b4d0bdd0bed0b5-d0bdd0b0d181d0bbd0b5d0b4d0bed0b2d0b0d0bdd0b8d0b5diamond-problema" id="a-hreflecturesoopinheritancetheoryhtmldiamond-problem-d180d0bed0bcd0b1d0bed0b2d0b8d0b4d0bdd0bed0b5-d0bdd0b0d181d0bbd0b5d0b4d0bed0b2d0b0d0bdd0b8d0b5diamond-problema"><a href="lectures/../oop/inheritance/theory.html#diamond-problem-%D1%80%D0%BE%D0%BC%D0%B1%D0%BE%D0%B2%D0%B8%D0%B4%D0%BD%D0%BE%D0%B5-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Diamond problem</a></a></h2>
<p><img src="lectures/img/16.png" alt="alt text" />
<img src="lectures/img/17.png" alt="alt text" /></p>
<pre><code class="language-cpp">Son s;
s.g; // CE - неоднозначность
s.Granny::g; // CE - неоднозначность
s.Mom::g; // OK
</code></pre>
<pre><code class="language-cpp">Granny&amp; g = s; // CE - неоднозначный каст
// нужно скастится к маме/папе, потом уже к бабушке
</code></pre>
<pre><code class="language-cpp">// если в бабушке метод void f()
s.f(); // CE
</code></pre>
<ul>
<li>
<p>касты между родителями одного уровня
<img src="lectures/img/18.png" alt="alt text" /><br />
так как не понятно, как сдвинуть адрес. В зависимости от того, как перечислены
наследуемые классы, надо делать либо сдвиг вправо, либо сдвиг влево</p>
</li>
<li>
<p>inaccessible base class<br />
к полям правой бабушки никак нельзя обратиться. Так не надо никогда делать<br />
<img src="lectures/img/19.png" alt="alt text" /></p>
</li>
<li>
<p>указатели на методы
<img src="lectures/img/20.png" alt="alt text" /><br />
но в чем тут проблема?
<img src="lectures/img/21.png" alt="alt text" />
указатель на метод хранит не только указатель на функцию, но и сдвиг объекта (на сколько байт начало того объекта, чей это метод, сдвинуто относительно начала того объекта, от которого мы вызвались)</p>
</li>
</ul>
<h2><a class="header" href="#a-hreflecturesoopinheritancetheoryhtmlvirtual-inheritanceВиртуальное-наследованиеa" id="a-hreflecturesoopinheritancetheoryhtmlvirtual-inheritanceВиртуальное-наследованиеa"><a href="lectures/../oop/inheritance/theory.html#virtual-inheritance">Виртуальное наследование</a></a></h2>
<p>Хотим, чтобы если мы 2 раза унаследуемся от одного и того же прородитель с разными промежуточными родителями, то этот прородитель не дублировался</p>
<ul>
<li>
<p>virtual
<img src="lectures/img/22.png" alt="alt text" /></p>
</li>
<li>
<p>как это работает
<img src="lectures/img/23.png" alt="alt text" />
ptr создается для тех классов, у которых есть виртуальный предок. ptr на самом деле указывает не сюда.
для каждого из типов в статической памяти будет создана некоторая структура данных, в которой будет для каждого виртуального предка будет статически указан сдвиг относительно начала объекта это предка - vtable
<img src="lectures/img/24.png" alt="alt text" /></p>
</li>
<li>
<p>при виртуальном наследовании static_cast вниз не работает<br />
не понятно, насколько сдвигаться - CE
<img src="lectures/img/25.png" alt="alt text" /></p>
</li>
<li>
<p>на самом деле таблица не одна на класс<br />
чтобы уметь кастоваться от папы к бабушке, надо знать не только оффсет бабушки относительно сына, но и оффсет нашего текущего объекта от реального начала объекта - top offset (так как папа лежит не первый, ему надо прыгнуть на 32 - его оффсет)
<img src="lectures/img/26.png" alt="alt text" />
в маме top offset 0, в папе 16</p>
</li>
<li>
<p>можно унаследовать класс один раз виртуально, другой раз не виртуально<br />
<img src="lectures/img/27.png" alt="alt text" />
дальше опять куча примеров про какой-то бред</p>
</li>
</ul>
<h1><a class="header" href="#Лекция-20" id="Лекция-20">Лекция 20</a></h1>
<h2><a class="header" href="#a-hreflecturesooppolymorphismtheoryhtmld0b8d0b4d0b5d18f-d0b2d0b8d180d182d183d0b0d0bbd18cd0bdd18bd185-d184d183d0bdd0bad186d0b8d0b9Виртуальные-функцииa" id="a-hreflecturesooppolymorphismtheoryhtmld0b8d0b4d0b5d18f-d0b2d0b8d180d182d183d0b0d0bbd18cd0bdd18bd185-d184d183d0bdd0bad186d0b8d0b9Виртуальные-функцииa"><a href="lectures/../oop/polymorphism/theory.html#%D0%B8%D0%B4%D0%B5%D1%8F-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D1%85-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9">Виртуальные функции</a></a></h2>
<pre><code class="language-cpp">struct Base {
    void f() {
        std::cout &lt;&lt; 1;
    }
};

struct Derived : Base {
    void f() {
        std::cout &lt;&lt; 2;
    }
};

int main() {
    Derived d;
    Base&amp; b = d;
    b.f(); // 1
}
</code></pre>
<p>но хотим, чтобы выполнялся частный случай</p>
<pre><code class="language-cpp">struct Base {
    virtual void f() {
        std::cout &lt;&lt; 1;
    }
};

struct Derived : Base {
    // можно так, но не обязательно
    // virtual void f() {
    void f() {
        std::cout &lt;&lt; 2;
    }
};

int main() {
    Derived d;
    Base&amp; b = d;
    b.f(); // 2
}
</code></pre>
<p>решение, какую функцию вызвать принимается в runtime<br />
но вот так будет настоящая копия</p>
<pre><code class="language-cpp">int main() {
    Derived d;
    Base b = d;
    b.f(); // 1
}
</code></pre>
<ul>
<li>
<p>полиморфный тип - у которого хотя бы 1 виртуальная функция (или хотя бы одна виртуальная функция унаследована)</p>
</li>
<li>
<p>деструктор</p>
</li>
</ul>
<pre><code class="language-cpp">struct Base {
    virtual void f() {
        std::cout &lt;&lt; 1;
    }
};

struct Derived : Base {
    int* p = new int(0);
    void f() {
        std::cout &lt;&lt; 2;
    }
    ~Derived(){
        delete p;
    }
};

int main() {
    Base* b = new Derived();
    delete b; // деструктор Base -&gt; утечка памяти
}
</code></pre>
<p>вывод: деструктор нужно делать виртуальным</p>
<pre><code class="language-cpp">struct Base {
    virtual void f() {
        std::cout &lt;&lt; 1;
    }
    virtual ~Base() = default;
};
</code></pre>
<p>или без default, но тогда не сможем работать с объектом Base</p>
<ul>
<li>сигнатура должна совпадать полностью</li>
</ul>
<pre><code class="language-cpp">struct Base {
    void f() const {
        std::cout &lt;&lt; 1;
    }
};

struct Derived : Base {
    void f() {
        std::cout &lt;&lt; 3;
    }
};

int main() {
    Derived d;
    Base&amp; b = d;
    b.f(); // 1
}
</code></pre>
<p>так же с возвращаемым типом</p>
<ul>
<li><a href="lectures/../oop/polymorphism/theory.html#override">override</a> может нас спасти (CE, если такой виртуальной функции нет у родителя) (C++11)<br />
!никак не влияет на поведение работы с виртуальными фукнциями, просто добавляет CE, если такой функции нет - подсказка для нас самих</li>
</ul>
<pre><code class="language-cpp">struct Derived : Base {
    void f() override {
        std::cout &lt;&lt; 3;
    }
};
</code></pre>
<ul>
<li><a href="lectures/../oop/polymorphism/theory.html#final">final</a> - запрещает всем дальнейшим наследникам переопределять функцию (с такой же сигнатурой) (C++11)</li>
</ul>
<pre><code class="language-cpp">struct Derived : Base {
    void f() final {
        std::cout &lt;&lt; 3;
    }
};
</code></pre>
<p><code>final</code> автоматически означает <code>override</code>. поэтому из слов <code>virtual</code>, <code>override</code>, <code>final</code> всегда требуется только одно</p>
<ul>
<li>другой смысл для классов</li>
</ul>
<pre><code class="language-cpp">struct Derived final : Base {};
</code></pre>
<p>от Derived больше нельзя наследоваться</p>
<ul>
<li>private</li>
</ul>
<pre><code class="language-cpp">struct Granny {
    virtual void f() const {
        std::cout &lt;&lt; 1;
    }
};

struct Mom : Granny {
private:
    void f() const override {
        std::cout &lt;&lt; 2;
    }
};

struct Son : Mom {
    void f() const final {
        std::cout &lt;&lt; 3;
    }
};

int main() {
    Mom m;
    Granny&amp; g = m;
    g.f(); // 2
}
</code></pre>
<p>виртуальные функции это runtime явления, а приватность - compile time. в compile time никак нельзя определить, какая функция будет выбрала в runtime.</p>
<p>но!</p>
<pre><code class="language-cpp">struct Granny {
private:
    virtual void f() const {
        std::cout &lt;&lt; 1;
    }
};

struct Mom : Granny {
    void f() const override {
        std::cout &lt;&lt; 2;
    }
};

struct Son : Mom {
    void f() const final {
        std::cout &lt;&lt; 3;
    }
};

int main() {
    Mom m;
    Granny&amp; g = m;
    g.f(); // CE
}
</code></pre>
<p>берем имя f() из бабушки, но оно приватно =&gt; CE</p>
<ul>
<li><a href="lectures/../oop/polymorphism/theory.html#abstract-classes-and-pure-virtual-function">абстрактный класс</a> - есть хотя бы 1 pure virtual функция<br />
аналог интерфейса</li>
</ul>
<pre><code class="language-cpp">struct Shape {
    virtual double area() const = 0; // pure virtual
    virtual ~Shape() = default;
};
</code></pre>
<p>нельзя создать объект абстрактного типа, но можно создавать ссылки и указатели такого типа на потомков</p>
<ul>
<li>но можно всё таки определить pure virtual функцию</li>
</ul>
<pre><code class="language-cpp">struct Shape {
    virtual double area() const = 0;
    virtual ~Shape() = default;
};

double Shape::area() {
    return 0.0;
}
</code></pre>
<ul>
<li><a href="lectures/../oop/polymorphism/theory.html#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC">полиморфизм</a></li>
</ul>
<pre><code class="language-cpp">struct Shape {
    virtual double area() const = 0;
    virtual ~Shape() = default;
};

struct Square : Shape {
    double a;
    Square(double a) : a(a) {}
    double area() const override {
        return a * a;
    }
};

struct Circle : Shape {
    double r;
    Circle(double r): r(r) {}
    double area() const override {
        return 3.14159265358 * r * r;
    }
};

int main() {
    std::vector&lt;Shape*&gt; v;
    v.push_back(new Square(1.0));
    v.push_back(new Circle(1.0));
    for (Shape* s : v) {
        std::cout &lt;&lt; s-&gt;area() &lt;&lt; &quot;\n&quot;;
    }
    for (Shape* s : v) {
        delete s;
    }
}
</code></pre>
<ul>
<li>можно явно попросить вызвать родиельскую</li>
</ul>
<pre><code class="language-cpp">int main() {
    Circle c(1.0);
    c.Shape::area();
}
</code></pre>
<h1><a class="header" href="#Лекция-21" id="Лекция-21">Лекция 21</a></h1>
<h2><a class="header" href="#a-hreflecturescastingtheoryhtml5-rtti-and-dynamic_castdynamic_casta" id="a-hreflecturescastingtheoryhtml5-rtti-and-dynamic_castdynamic_casta"><a href="lectures/../casting/theory.html#5-rtti-and-dynamic_cast">dynamic_cast</a></a></h2>
<ul>
<li>dynamic_cast (runtime cast) - только для для полиморфных типов (исходный тип должен быть полиморфным)</li>
</ul>
<pre><code class="language-cpp">struct Base {
    virtual void f() {}
    virtual ~Base() = default;
};

struct Derived : Base {
    void f() override {}
};

int main() {
    Derived d;
    Base&amp; b = d;
    dynamic_cast&lt;Derived&amp;&gt;(b);
}
</code></pre>
<p>проверит, на самом ли деле под b лежит Derived&amp;. иначе кинет std::bad_cast</p>
<pre><code class="language-cpp">dynamic_cast&lt;Derived*&gt;(&amp;b);
</code></pre>
<p>аналогично проверит, но вернет <code>nullptr</code><br />
довольная дорогая операция</p>
<ul>
<li>
<p>можно делать каст от любого полиморфного типа к void*</p>
</li>
<li>
<p>умеет кастовать вбок (от мамы к папе) (исходный тип должен быть полиморфным)</p>
</li>
<li>
<p>можно делать dynamic_cast вверх, даже если тип не полиморфный (как и static_cast)</p>
</li>
<li>
<p>можно делать dynamic_cast вниз при виртуальном наследовании от полиморфного типа</p>
</li>
</ul>
<h2><a class="header" href="#rtti" id="rtti">RTTI</a></h2>
<ul>
<li>
<p>в каждом объекте полиморфного типа хранится runtime type information</p>
</li>
<li>
<p>оператор typeid<br />
возвращает std::type_info</p>
</li>
</ul>
<pre><code class="language-cpp">std::cout &lt;&lt; typeid(b).name(); // название типа, который реально был под ссылкой
// const char*
</code></pre>
<p>работает и не для полиморфных типов<br />
type_info можно сравнивать</p>
<h2><a class="header" href="#a-hreflecturescastingtheoryhtml6-memory-layout-of-polymorphic-objectsРасположение-в-памяти-полиморфных-объектовa" id="a-hreflecturescastingtheoryhtml6-memory-layout-of-polymorphic-objectsРасположение-в-памяти-полиморфных-объектовa"><a href="lectures/../casting/theory.html#6-memory-layout-of-polymorphic-objects">Расположение в памяти полиморфных объектов</a></a></h2>
<p>формально не является стандартом C++</p>
<ul>
<li>
<p>vtable
<img src="lectures/img/28.png" alt="alt text" /></p>
</li>
<li>
<p>наследования
<img src="lectures/img/29.png" alt="alt text" />
каст от сына к бабушке должен сместить указатель (причем это умеет даже static_cast)<br />
обратно сделать dynamic_cast уже не получится, т.к. бабушка не полиморфна (но static_cast можно в обе стороны!)</p>
</li>
</ul>
<h1><a class="header" href="#Лекция-22" id="Лекция-22">Лекция 22</a></h1>
<h2><a class="header" href="#Множественное-наследование" id="Множественное-наследование">Множественное наследование</a></h2>
<ul>
<li>
<p>обычное наследование
<img src="lectures/img/30.png" alt="alt text" />
первый ptr общий для мамы и сына, второй для папы (они ведут в разные таблицы)
<img src="lectures/img/31.png" alt="alt text" />
если вызываем f() из папы, но сам объект - сын, надо вычесть top offset, чтобы могли работать с полями сына</p>
</li>
<li>
<p>виртуальное наследование
<img src="lectures/img/32.png" alt="alt text" />
virtual offset - оффсет виртуального родителя от начала<br />
top offset - оффсет нашего объекта от реального начала</p>
</li>
</ul>
<h2><a class="header" href="#a-hreflecturescastingtheoryhtml8-non-obvious-problems-with-virtual-functionsПроблемы-с-виртуальными-функциямиa" id="a-hreflecturescastingtheoryhtml8-non-obvious-problems-with-virtual-functionsПроблемы-с-виртуальными-функциямиa"><a href="lectures/../casting/theory.html#8-non-obvious-problems-with-virtual-functions">Проблемы с виртуальными функциями</a></a></h2>
<ul>
<li>
<p>нельзя не определить виртуальную функцию (кроме pure virtual), так как компилятор должен сгенерировать vtable c указателем на функцию, а линкер не сможет ее найти</p>
</li>
<li>
<p>из конструктора вызывается не виртуальная функция, а обычная</p>
</li>
</ul>
<p>мне лень писать все примеры, потому что это полный бред. можно почитать по ссылке выше</p>
<h2><a class="header" href="#Некоторые-статьи" id="Некоторые-статьи">Некоторые статьи</a></h2>
<p><a href="https://www.drdobbs.com/cpp/multiple-inheritance-considered-useful/184402074">Multiple Inheritance Considered Useful</a> - статья про множественное наследование и виртуальные функции (в 7 страницах ☠️)</p>
<p><a href="https://shaharmike.com/cpp/">Shahar Mike's Web Spot</a> - блог какого-то крутого чувака, где есть подробные статьи про vtables с разбором, как они работают и располагаются в памяти</p>
<h1><a class="header" href="#Лекция-23" id="Лекция-23">Лекция 23</a></h1>
<h2><a class="header" href="#Шаблоны" id="Шаблоны">Шаблоны</a></h2>
<ul>
<li>шаблоны функций</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
void swap(T&amp; x, T&amp; y) {
    T t = x;
    x = y;
    y = t;
}

template &lt;typename T&gt;
T max(T x, T y) {
    return x &gt; y ? x : y;
}
// это, конечно, плохие реализации
</code></pre>
<p>можно писать</p>
<pre><code class="language-cpp">template &lt;class T&gt; // old style
</code></pre>
<p>разницы нет, кроме очень редких случаев (не будем разбирать)</p>
<ul>
<li>шаблоны классов</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
class vector {
    T* arr;
    size_t sz;
    size_t cap;
};
</code></pre>
<ul>
<li>шаблоны using (C++11)</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
using mymap = std::map&lt;T, T, std::greater&lt;T&gt;&gt;;
</code></pre>
<ul>
<li>
<p>шаблоны переменных (constexpr) (C++14) - разберём позже</p>
</li>
<li>
<p>концепты (C++20) - разберём позже</p>
</li>
<li>
<p>выведение шаблонного параметра (Template argument deduction)</p>
</li>
</ul>
<pre><code class="language-cpp">int a = 0;
int b = 1;
swap(a, b); // можно не указывать явно
</code></pre>
<p>но вот так CE</p>
<pre><code class="language-cpp">int a = 0;
long long b = 1;
swap(a, b); // не понятно, какой T имеется в виду
</code></pre>
<ul>
<li>кодогенерация - главная идея шаблонов!<br />
глядя на то, от каких T мы вызываемся, компилятор должен понять, какой код сгенерировать</li>
</ul>
<pre><code class="language-cpp">int a1 = 0, b1 = 1;
swap(a1, b1);

long long a2 = 0, b2 = 1;
swap(a2, b2);

swap(a1, a2); // CE
</code></pre>
<p>стадия генерации должна пройти целиком до того, как начнется стадия выбора версий !!! (дальше будет поправка)</p>
<p>но можно указать явно, какую версию использовать (без deduction)</p>
<pre><code class="language-cpp">swap&lt;long long&gt;(a1, b1); // CE
</code></pre>
<p>теперь будет CE, из-за того, что нельзя проинициализировать неконстантную ссылку на long long через int, но если принимать по значению - OK (сделается каст от int к long long)</p>
<ul>
<li>с классами аналогично</li>
</ul>
<pre><code class="language-cpp">std::vector&lt;int&gt; v;
std::vector&lt;double&gt; v; // сгенерирует 2 абсолютно разных класса

v2 = v; // CE, нет конверсии от одного к другому
// т.к. это 2 абсолютно разных класса
</code></pre>
<h2><a class="header" href="#Перегрузка-шаблонных-функций" id="Перегрузка-шаблонных-функций">Перегрузка шаблонных функций</a></h2>
<ul>
<li>частное лучше общего</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
void f(T x) {}

void f(int x) {} // идеальное соответствие типа

int main() {
    int x = 0;
    f(x); // OK, выберется 2 версия
}
</code></pre>
<p>(поправка к теме кодогенерации)<br />
на самом деле, если есть выбор между шаблонной версией и не шаблонной, то это решение принимается раньше - до того, как компилятор начинет генерировать шаблонную версию. в примере выше шаблонная версия не сгенерируется. (на самом деле это тоже не совсем правда, дальше будет 2 поправка)</p>
<p>!но, если частная версия не так хорошо подходит, как общая, то выберется общая</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void f(T x) {}

void f(long long x) {}

int main() {
    int x = 0;
    f(x); // сгенерируется шаблонная для int
}
</code></pre>
<p>итого есть 2 правила:</p>
<ol>
<li>частное лучше общего</li>
<li>не смотря на это, точное соответствие лучше чем хоть какой-то каст</li>
</ol>
<p>но, опять же, можно указать явно</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void f(T x) {
    std::cout &lt;&lt; 1;
}

void f(int x) {
    std::cout &lt;&lt; 2;
}

int main() {
    int x = 0;
    f&lt;long long&gt;(x); // 1
    f&lt;int&gt;(x); // 1, обязываем компилятор выбрать именно шаблонную версию
}
</code></pre>
<p>здесь нет deduction, поэтому всё проще</p>
<ul>
<li>шаблонные аргументы по умолчанию<br />
они должны быть последними, как и обычные аргументы у функций</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T = int&gt;
void f(T x) {}
</code></pre>
<pre><code class="language-cpp">template &lt;typename T, typename U = int&gt;
U f(T x) {
    return 0;
}
</code></pre>
<p>тогда при вызове можно указывать не все типы</p>
<ul>
<li>ссылки<br />
смысл ссылок в том, чтобы они были неотличимы от исходной переменной</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T = int&gt;
void f(T&amp; x) {
    std::cout &lt;&lt; 1;
}

template &lt;typename T = int&gt;
void f(T x) {
    std::cout &lt;&lt; 2;
}

int main() {
    int x = 0;
    f(x); // CE
}
</code></pre>
<p>здесь CE будет и без шаблонов<br />
но</p>
<pre><code class="language-cpp">f(1); // 2
</code></pre>
<h2><a class="header" href="#cпециализации-шаблонов" id="cпециализации-шаблонов">Cпециализации шаблонов</a></h2>
<ul>
<li>классы</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
class vector {
    T* arr;
    size_t sz;
    size_t cap;
};

// full specialization
template &lt;&gt;
class vector&lt;bool&gt; {
    char* arr;
    size_t sz;
    size_t cap;
};
</code></pre>
<p>в шаблонном префиксе указываем те аргументы, которые пригодятся для объяснения, какую именно специализацию хотим объявить (<code>template &lt;&gt;</code> - ничего не нужно для этой специализации), а дальше указываем саму специализацию справа от названия класса</p>
<pre><code class="language-cpp">template &lt;typename T, typename U&gt;
class S {};

// partial specialization
template &lt;typename T&gt;
class S&lt;T, T&gt; {};
</code></pre>
<p><code>template &lt;typename T&gt;</code> - нужен T</p>
<p>можно делать так</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
class S {};

template &lt;typename T&gt;
class S&lt;T&amp;&gt; {};

template &lt;typename T&gt;
class S&lt;const T&gt; {};
</code></pre>
<p>но, нельзя переопределять классы с другим количеством шаблонных параметров</p>
<pre><code class="language-cpp">template &lt;typename T, typename U&gt;
struct A {};

template &lt;typename T&gt; // CE
struct A {};
</code></pre>
<p>не существует перегрузки классов!</p>
<h1><a class="header" href="#Лекция-24" id="Лекция-24">Лекция 24</a></h1>
<h2><a class="header" href="#cпециализации-шаблонов-1" id="cпециализации-шаблонов-1">Cпециализации шаблонов</a></h2>
<ul>
<li>функции</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T, typename U&gt;
void f(T, U) {
    std::cout &lt;&lt; 1;
}

template &lt;typename T&gt;
void f(T, T) {
    std::cout &lt;&lt; 2;
}

int main() {
    f(0, 0); // 2
}
</code></pre>
<p>вторая версия более частная</p>
<ul>
<li>окунаемся</li>
</ul>
<p>для функций запрещена частичная специализация</p>
<p>но можно переопределять функцию с другим количеством шаблонных параметров (в отличии от классов), т.к. у функций есть перегрузка. здесь №2 не является специализацей №1</p>
<p>для функций можно делать только полную специализацию <code>template &lt;&gt;</code>. здесь №3 - специализация для №1, но №2 выигрывает, т.к. она исходно более частная, чем №1</p>
<pre><code class="language-cpp">template &lt;typename T, typename U&gt;
void f(T, U) {
    std::cout &lt;&lt; 1;
}
template &lt;&gt;
void f(int, int) {
    std::cout &lt;&lt; 3;
}
template &lt;typename T&gt;
void f(T, T) {
    std::cout &lt;&lt; 2;
}

int main() {
    f(0, 0); // 2
}
</code></pre>
<p>но, если поменять местами, №3 - уже специализация для №2. и тогда выигрывает ветка №2, а именно её специализация - №3</p>
<pre><code class="language-cpp">template &lt;typename T, typename U&gt;
void f(T, U) {
    std::cout &lt;&lt; 1;
}
template &lt;typename T&gt;
void f(T, T) {
    std::cout &lt;&lt; 2;
}
template &lt;&gt;
void f(int, int) {
    std::cout &lt;&lt; 3;
}

int main() {
    f(0, 0); // 3
}
</code></pre>
<p>помимо всего прочего, можно объявить вообще не шаблонную функцию</p>
<pre><code class="language-cpp">template &lt;typename T, typename U&gt;
void f(T, U) {
    std::cout &lt;&lt; 1;
}
template &lt;typename T&gt;
void f(T, T) {
    std::cout &lt;&lt; 2;
}
template &lt;&gt;
void f(int, int) {
    std::cout &lt;&lt; 3;
}
void f(int, int) {
    std::cout &lt;&lt; 4;
}

int main() {
    f(0, 0); // 4
}
</code></pre>
<p>здесь у нас как бы 3 версии (ветки) перегрузки, у одной из которых есть ещё специализация: шаблонная версия №1 с 2 параметрами, шаблонная версия №2 с 1 параметром, обычная версия №4 - не шаблонная, а у шаблонной версии №2 есть частный случай - №3</p>
<p>(2 поправка к теме кодогенерации)<br />
на самом деле: компилятор смотрит на версии перегрузки (их здесь 3 - №1,№2,№4). но у некоторых из них ещё могут быть специализации (№2). тем не менее, компилятор сначала выбирает между версиями перегрузки, а потом уже решает, нет ли у неё специализации, подходящей для данного случая.</p>
<p>сначала из шаблонов выбирается наиболее подходящий шаблон или принимается решение, что шаблон не нужен вообще (как в последнем примере). потом в подходящий шаблон (если был выбран шаблон) подставляются аргументы, и решается, какая из специализаций подходит лучше всего. то есть генерируются версии для специализаций и делается перегрузка между тем, что получилось</p>
<p>последний пример</p>
<pre><code class="language-cpp">template &lt;typename T, typename U&gt;
void f(T, U) {
    std::cout &lt;&lt; 1;
}
template &lt;&gt;
void f(int, int) {
    std::cout &lt;&lt; 3;
}
template &lt;typename T&gt;
void f(T, T) {
    std::cout &lt;&lt; 2;
}
template &lt;&gt;
void f(int, int) {
    std::cout &lt;&lt; 4;
}

int main() {
    f(0, 0); // 4
}
</code></pre>
<p>здесь №3 - специализация №1, №4 - специализация №2. при первом выборе версии перегрузки выберется №2, т.к. она более частная, а дальше выберется специализация №4, т.к. она лучшая</p>
<p>хыхы пон, удачи это запомнить</p>
<h2><a class="header" href="#non-type-template-parameters-nttp" id="non-type-template-parameters-nttp">Non-type template parameters (nttp)</a></h2>
<p>не только типы могут быть параметрами шаблона</p>
<p>(в C++20 всё изменилось) - обсудим позже</p>
<ul>
<li>целочисленные типы, char, bool</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T, size_t N&gt;
class array {
    T arr[N];
};

array&lt;int, 100&gt; a;
</code></pre>
<pre><code class="language-cpp">template &lt;size_t M, size_t N, typename Field = Rational&gt;
class Matrix {};

template &lt;size_t N, typename Field = Rational&gt;
using SquareMatrix = Marix&lt;N, N, Field&gt;;

int main() {
    Matrix&lt;5, 5&gt; m;
    SquareMatrix&lt;5&gt; sm;
}
</code></pre>
<pre><code class="language-cpp">template &lt;size_t M, size_t K, size_t N, typename Field = Rational&gt;
Matrix&lt;M, N, Field&gt; operator*(const Matrix&lt;M, K, Field&gt;&amp; a, const Matrix&lt;K, N, Field&gt;&amp; b);
</code></pre>
<p>можно перемножать только матрицы нужных размеров над одним полем, иначе CE</p>
<ul>
<li>можно подставлять только константы, известные в compile time</li>
</ul>
<pre><code class="language-cpp">int x = 5;
Matrix&lt;x, x&gt; m; // CE
</code></pre>
<pre><code class="language-cpp">const int x = 5;
Matrix&lt;x, x&gt; m; // OK
Matrix&lt;5, 5&gt; m2; // OK
</code></pre>
<p>но, очевидно</p>
<pre><code class="language-cpp">int x;
std::cin &gt;&gt; x;
const int y = x;
Matrix&lt;y, y&gt; m; // CE, 'y' is not usable in constant expression
</code></pre>
<ul>
<li>constexpr (C++11) - забегаем вперёд<br />
гарантирует, что значение переменной известно, в момент компиляции</li>
</ul>
<pre><code class="language-cpp">int x; cin &gt;&gt; x;
constexpr int y = x; // CE именно на этой строчке
Matrix&lt;y, y&gt; m;
</code></pre>
<p>строго говоря, в шаблоны мы можем передавать именно такие константы</p>
<h2><a class="header" href="#Шаблонные-аргументы-которые-сами-являются-шаблонами" id="Шаблонные-аргументы-которые-сами-являются-шаблонами">Шаблонные аргументы, которые сами являются шаблонами</a></h2>
<p>Template template parameters</p>
<p>хотим указать, что шаблонным параметром является другой шаблонный класс</p>
<pre><code class="language-cpp">template &lt;typename T, template &lt;typename&gt; class Container&gt;
class Stack {
    Container&lt;T&gt; container;
};
</code></pre>
<p>тут есть разница между class и typename. до C++17 надо было писать class. начиная с C++17 можно typename</p>
<pre><code class="language-cpp">template &lt;typename T, template &lt;typename&gt; typename Container&gt;
class Stack {
    Container&lt;T&gt; container;
};
</code></pre>
<p>здесь Container это не конечный тип, а шаблон. его нужно параметризовать типом уже в теле класса</p>
<pre><code class="language-cpp">template &lt;typename T, template &lt;typename, typename&gt; typename Container = std::vector&gt;
class Stack {
    Container&lt;T, std::allocator&lt;T&gt;&gt; container;
};
</code></pre>
<ul>
<li>адаптеры над контейнерами (<code>std::stack</code>, <code>std::queue</code>, <code>std::priority_queue</code>) принимают вторым шаблонным аргументом конкретный тип контейнера (<code>std::vector&lt;T&gt;</code>) из-за аллокатора. Без этого мы бы не смогли туда передавать контейнер без аллокатора, например свой кастомный контейнер</li>
</ul>
<h2><a class="header" href="#compile-time-вычисления" id="compile-time-вычисления">Compile time вычисления</a></h2>
<ul>
<li>Фиббоначи</li>
</ul>
<pre><code class="language-cpp">template &lt;size_t N&gt;
struct Fibonacci {
    static constexpr int value = Fibonacci&lt;N-1&gt;::value + Fibonacci&lt;N-2&gt;::value;
};
// template instantiation depth exceeds maximum of 900 (use ‘-ftemplate-depth=’ to increase the maximum)

int main() {
    std::cout &lt;&lt; Fibonacci&lt;20&gt;::value;
}
</code></pre>
<p><code>static</code> - хотим сделать поле частью типа, а не одного объекта</p>
<pre><code class="language-cpp">template &lt;size_t N&gt;
struct Fibonacci {
    static constexpr int value = Fibonacci&lt;N-1&gt;::value + Fibonacci&lt;N-2&gt;::value;
};

template &lt;&gt;
struct Fibonacci&lt;0&gt; {
    static constexpr int value = 0;
};

template &lt;&gt;
struct Fibonacci&lt;1&gt; {
    static constexpr int value = 1;
};

int main() {
    std::cout &lt;&lt; Fibonacci&lt;20&gt;::value; // O(n) по памяти и времени
}
</code></pre>
<p>на самом деле даже с -O0 такое оптимизируется
<a href="https://godbolt.org/z/6rWhjr4oT">godbolt</a></p>
<pre><code class="language-cpp">main:
        push    rbp
        mov     rbp, rsp
        mov     esi, 6765
        mov     edi, OFFSET FLAT:std::cout
        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)
        mov     eax, 0
        pop     rbp
        ret
</code></pre>
<ul>
<li>проверка числа на простоту</li>
</ul>
<pre><code class="language-cpp">template&lt;int N, int D&gt;
struct IsPrimeHelper {
    static constexpr bool value = N%D == 0 ? false : IsPrimeHelper&lt;N, D-1&gt;::value;
};

template&lt;int N&gt;
struct IsPrimeHelper&lt;N, 1&gt; {
    static constexpr bool value = true;
};

template&lt;int N&gt;
struct IsPrime {
    static constexpr bool value = IsPrimeHelper&lt;N, N-1&gt;::value;
};

template&lt;&gt;
struct IsPrime&lt;1&gt; {
    static constexpr bool value = false;
};

int main() {
    std::cout &lt;&lt; IsPrime&lt;257&gt;::value; // O(n) по памяти и времени
}
</code></pre>
<ul>
<li>шаблонная переменная (C++14)</li>
</ul>
<pre><code class="language-cpp">template &lt;int N&gt;
const bool is_prime = IsPrime&lt;N&gt;::value; // метафункция

int main() {
    std::cout &lt;&lt; is_prime&lt;257&gt;;
}
</code></pre>
<ul>
<li>static_assert<br />
только от константных выражений</li>
</ul>
<pre><code class="language-cpp">int main() {
    static_assert(is_prime&lt;257&gt;);
}
</code></pre>
<p>кидает CE, если false</p>
<h1><a class="header" href="#Лекция-25" id="Лекция-25">Лекция 25</a></h1>
<h2><a class="header" href="#dependent-names" id="dependent-names">Dependent names</a></h2>
<p>когда мы работаем с шаблонами, компилятор не всегда знает, является ли имя функцией, типом или чем-то другим, что приводит к потенциальным ошибкам при компиляции</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct S {
    using A = int;
};

template &lt;&gt;
struct S&lt;double&gt; {
    static const int A = 5;
};

// int x = 0;

template &lt;typename T&gt;
void f() {
    S&lt;T&gt;::A* x; // CE, error: dependent-name ‘S&lt;T&gt;::A’ is parsed as a non-type, but instantiation yields a type
}

int main() {
    f&lt;int&gt;();
}
</code></pre>
<p>в одной из версий шаблона имя может обозначать тип, а в другой переменную. <code>int* x</code> или <code>5*x</code> -&gt; declaration или expression?
(представим, что есть глобальная переменная x)</p>
<ul>
<li>
<p>по дефолту компилятор считает, что все dependent names это expression</p>
</li>
<li>
<p>перед зависимым именем надо писать <code>typename</code>, чтобы компилятор парсил его как названия типа, а не как expression</p>
</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
void f() {
    typename S&lt;T&gt;::A* x;
}
</code></pre>
<p>ещё пример</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void printValue() {
    T::value_type x; // CE
}
</code></pre>
<pre><code class="language-cpp">template &lt;typename T&gt;
void printValue() {
    typename T::value_type x; // OK, typename указывает компилятору, что это тип
}
</code></pre>
<p>начиная с C++20 количество контекстов, в которых он воспринимает это как переменную уменьшилось</p>
<ul>
<li>другая проблема</li>
</ul>
<pre><code class="language-cpp">#include &lt;array&gt;

template &lt;typename T&gt;
struct S {
    template &lt;int N&gt;
    using A = std::array&lt;int, N&gt;;
};

template &lt;&gt;
struct S&lt;double&gt; {
    static const int A = 5;
};

template &lt;typename T&gt;
void f() {
    typename S&lt;T&gt;::A&lt;10&gt; x; // CE (хотя в новых версиях g++ такой проблемы нет)
}

int main() {
    f&lt;int&gt;();
}
</code></pre>
<p>такое можно распарсить, как <code>A &lt; 10 &gt; x</code>. слова <code>typename</code> здесь не достаточно. оно заставляет компилятор считать это названием типа, но не шаблона</p>
<p>решение</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void f() {
    typename S&lt;T&gt;::template A&lt;10&gt; x;
}
</code></pre>
<ul>
<li>ещё пример</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct S {
    template &lt;int N&gt;
    void foo(int) {}
};

template &lt;typename T&gt;
void bar(int x, int y) {
    S&lt;T&gt; s;
    s.foo&lt;5&gt;(x + y); // CE, error: invalid operands of types ‘&lt;unresolved overloaded function type&gt;’ and ‘int’ to binary ‘operator&lt;’
}

int main() {
    bar&lt;int&gt;(2, 3);
}
</code></pre>
<p>аналогично, такое можно распарсить, как <code>s.foo &lt; 5 &gt; (x + y)</code>.</p>
<p>решение</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void bar(int x, int y) {
    S&lt;T&gt; s;
    s.template foo&lt;5&gt;(x + y);
}
</code></pre>
<ul>
<li>пример с наследованием</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct Base {
    int x = 0;
};

template &lt;&gt;
struct Base&lt;double&gt; {};

template &lt;typename T&gt;
struct Derived : Base&lt;T&gt; {
    void f() {
        ++x; // CE, error: ‘x’ was not declared in this scope
    };
};
</code></pre>
<p>в зависимости от T, x может как присустствовать, так и отсутствовать в классе. может были либо полем, либо названием типа, либо названием метода.</p>
<p>решение</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct Derived : Base&lt;T&gt; {
    void f() {
        ++this-&gt;x;
    };
};
</code></pre>
<p>если хотим обратиться к полю шаблонного родителя, надо писать <code>this</code>.</p>
<p>или</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct Derived : Base&lt;T&gt; {
    void f() {
        ++Base&lt;T&gt;::x;
    };
};
</code></pre>
<ul>
<li>
<p>почитать ещё можно тут <a href="https://en.cppreference.com/w/cpp/language/dependent_name">cppreference</a></p>
</li>
<li>
<p>two phase translation (<a href="https://en.cppreference.com/w/cpp/language/two-phase_lookup">Two-phase name lookup</a>)<br />
компилятор генерирует шаблонный код в 2 прохода. 1) до того, как мы подставили T. мы смотрим на синтаксис и базовые семантические проверки (имена, не зависимые от T). 2) после подстановки T. там всплывают другие ошибки. поэтому часто, если не использовали какой-то шаблонный код, то много ошибок компиляции может не найтись. но как только мы инстанцировали шаблон, выпадет куча ошибок.</p>
</li>
</ul>
<h2><a class="header" href="#type_traits-c11" id="type_traits-c11">type_traits (C++11)</a></h2>
<ul>
<li>метафункции - функции от типов<br />
функции (в обобщённом смысле), которые принимают типы и возвращают типы/значения</li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_same"><code>std::is_same</code></a></li>
</ul>
<p>простейшая метафункция - хотим проверить, равны ли 2 типа</p>
<pre><code class="language-cpp">template &lt;typename T, typename U&gt;
struct is_same {
    static constexpr bool value = false;
};

template &lt;typename T&gt;
struct is_same&lt;T, T&gt; {
    static constexpr bool value = true;
};

template &lt;typename T, typename U&gt;
void f(const T&amp; x, const U&amp; y) {
    // ...
    if constexpr (is_same&lt;T, U&gt;::value) { // C++17
        x = y; // здесь можно делать что-то, что применимо только к к одинаковым типам
    }
    // ...
}
</code></pre>
<p>можно через typeid, но в runtime. Но если никакого полиморфизма нет, то можно просто для разных пар T, U в compile time сгенерировать разный код</p>
<p>под <code>if constexpr</code> проверится compile time условие. Если оно ложно, код под ифом даже не сгенерируется для данной пары</p>
<p>если написать только <code>if</code>, но код ниже всё равно будет пытаться скомпилироваться, даже для разных типов. сама проверка произойдёт только в рантайме. поэтому код сверху даже не скомпилируется, т.к. нельзя присвоить инту строку</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/remove_reference"><code>std::remove_reference</code></a></li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct remove_reference {
    using type = T;
};

template &lt;&gt;
struct remove_reference&lt;T&amp;&gt; {
    using type = T;
};

template &lt;typename T&gt;
void f() {
    typename remove_reference&lt;T&gt;::type x;
}
</code></pre>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/remove_cv"><code>std::remove_const</code></a></li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct remove_const {
    using type = T;
};

template &lt;&gt;
struct remove_const&lt;const T&gt; {
    using type = T;
};
</code></pre>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral_constant</code></a><br />
грубо говоря, просто константа конкретного типа</li>
</ul>
<pre><code class="language-cpp">template&lt;class T, T v&gt;
struct integral_constant {
    static constexpr T value = v;
    // ...
};
</code></pre>
<p>частные случаи для bool</p>
<pre><code class="language-cpp">template&lt; bool B &gt;
using bool_constant = integral_constant&lt;bool, B&gt;;
</code></pre>
<pre><code class="language-cpp">std::true_type  // std::integral_constant&lt;bool, true&gt;
std::false_type // std::integral_constant&lt;bool, false&gt;
</code></pre>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/is_array"><code>std::is_array</code></a></li>
</ul>
<pre><code class="language-cpp">template&lt;class T&gt;
struct is_array : std::false_type {};
 
template&lt;class T&gt;
struct is_array&lt;T[]&gt; : std::true_type {};
 
template&lt;class T, std::size_t N&gt;
struct is_array&lt;T[N]&gt; : std::true_type {};
</code></pre>
<p>аналогично, как писали до этого. просто для простоты наследуемся от <code>std::true_type</code> и <code>std::false_type</code></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/is_member_pointer"><code>std::is_member_pointer</code></a></li>
</ul>
<pre><code class="language-cpp">template&lt;class T&gt;
struct is_member_pointer_helper : std::false_type {};
 
template&lt;class T, class U&gt;
struct is_member_pointer_helper&lt;T U::*&gt; : std::true_type {};
 
template&lt;class T&gt;
struct is_member_pointer : is_member_pointer_helper&lt;typename std::remove_cv&lt;T&gt;::type&gt; {};
</code></pre>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/rank"><code>std::rank</code></a> - размерность массива (количество скобок <code>[]</code>)</li>
</ul>
<pre><code class="language-cpp">template&lt;class T&gt;
struct rank : public std::integral_constant&lt;std::size_t, 0&gt; {};
 
template&lt;class T&gt;
struct rank&lt;T[]&gt; : public std::integral_constant&lt;std::size_t, rank&lt;T&gt;::value + 1&gt; {};
 
template&lt;class T, std::size_t N&gt;
struct rank&lt;T[N]&gt; : public std::integral_constant&lt;std::size_t, rank&lt;T&gt;::value + 1&gt; {};
</code></pre>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/conditional"><code>std::conditional</code></a> - тернарый мета оператор</li>
</ul>
<pre><code class="language-cpp">template &lt;bool B, typename T, typename F&gt;
struct conditional {
    using type = F;
};

template &lt;typename T, typename F&gt;
struct conditional&lt;true, T, F&gt; {
    using type = T;
};
</code></pre>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/remove_extent"><code>std::remove_extent</code></a> - удаляет все скобочки <code>[]</code> из типа (делает из массива обычный тип)</li>
</ul>
<pre><code class="language-cpp">template&lt;class T&gt;
struct remove_extent { using type = T; };
 
template&lt;class T&gt;
struct remove_extent&lt;T[]&gt; { using type = T; };
 
template&lt;class T, std::size_t N&gt;
struct remove_extent&lt;T[N]&gt; { using type = T; };
</code></pre>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/decay"><code>std::decay</code></a> - снимает с типа все возможные украшения</li>
</ul>
<p>массив превращает в поинтер, функцию или ссылку на функцию в поинтер, остальное - <code>std::remove_cv</code></p>
<pre><code class="language-cpp">template&lt;class T&gt;
struct decay
{
private:
    typedef typename std::remove_reference&lt;T&gt;::type U;
public:
    typedef typename std::conditional&lt; 
        std::is_array&lt;U&gt;::value,
        typename std::add_pointer&lt;typename std::remove_extent&lt;U&gt;::type&gt;::type,
        typename std::conditional&lt; 
            std::is_function&lt;U&gt;::value,
            typename std::add_pointer&lt;U&gt;::type,
            typename std::remove_cv&lt;U&gt;::type
        &gt;::type
    &gt;::type type;
};
</code></pre>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/header/type_traits">все функции</a></li>
</ul>
<p>это всё появилось в C++11, а также шаблонные using. в C++14 доопределили структуры, которые возвращали тип (<code>::type</code>), шаблонными using для удобства. но также в C++14 добавили шаблонные переменные. в C++17 доопределили структуры, которые возвращали значения (<code>::value</code>), шаблонными переменными</p>
<p>вот такой вот хихик</p>
<ul>
<li>лучше не использовать все эти структуры в чистом виде, а использовать шаблонные using (C++14)</li>
</ul>
<pre><code class="language-cpp">template &lt;bool B, typename T, typename F&gt;
using conditional_t = typename conditional&lt;B, T, F&gt;::type;
</code></pre>
<p><code>_t</code> в конце</p>
<ul>
<li>а еще шаблонные переменные (C++17)</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T, typename U&gt;
const bool is_same_v = is_same&lt;T, U&gt;::value;
</code></pre>
<p><code>_v</code> в конце</p>
<h2><a class="header" href="#variadic-templates" id="variadic-templates">Variadic templates</a></h2>
<ul>
<li>шаблоны с переменным количеством аргументов (C++11)</li>
</ul>
<pre><code class="language-cpp">template &lt;typename... Types&gt; // объявили пачку типов
void f(Types... tx) { // распаковали пачку типов
    // теперь tx это пачка переменных
    g(tx...); // её можно распаковать дальше
}
</code></pre>
<p>эти типы могут быть разными! при этом, пакет может быть и пустым</p>
<pre><code class="language-cpp">void print() {} // база рекурсии

// хотя бы 1 аргумент должен быть
template &lt;typename Head, typename... Tail&gt;
void print(const Head&amp; head, const Tail&amp;... tail) {
    std::cout &lt;&lt; head &lt;&lt; ' ';
    print(tail...);
}

int main() {
    print(1, 2.0, &quot;abc&quot;);
}
</code></pre>
<ul>
<li><code>is_homogeneous</code><br />
проверяет, что все типы в пакете одинаковые</li>
</ul>
<pre><code class="language-cpp">template &lt;typename First, typename Second, typename... Types&gt;
struct is_homogeneous {
    static constexpr bool value = std::is_same&lt;First, Second&gt; &amp;&amp; is_homogeneous&lt;Second, Types...&gt;::value;
};

template &lt;typename First, typename Second&gt;
struct is_homogeneous&lt;First, Second&gt; {
    static constexpr bool value = std::is_same_v&lt;First, Second&gt;;
};
</code></pre>
<p>т.к. нельзя переопределять классы с другим количеством шаблонных параметров. поэтому здесь вторая стуктура - специализация первой с пустым пакетом аргументов</p>
<ul>
<li>оператор <code>sizeof...()</code> - в compile time возвращает размер пакета</li>
</ul>
<pre><code class="language-cpp">template &lt;typename Head, typename... Tail&gt;
void print(const Head&amp; head, const Tail&amp;... tail) {
    std::cout &lt;&lt; sizeof...(tail) &lt;&lt; &quot; &quot;; // размер
    print(tail...);
}
</code></pre>
<ul>
<li>
<p>такое можно делать и в C-стиле с помощью макросов <a href="https://en.cppreference.com/w/c/variadic">cppreference</a></p>
</li>
<li>
<p>также статья <a href="https://www.scs.stanford.edu/%7Edm/blog/param-pack.html">C++20 idioms for parameter packs</a>, но для прочтения надо хорошо понимать нововведения C++20</p>
</li>
</ul>
<h1><a class="header" href="#Лекция-26" id="Лекция-26">Лекция 26</a></h1>
<h2><a class="header" href="#Выражения-свёртки" id="Выражения-свёртки">Выражения свёртки</a></h2>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/fold">Fold expressions</a> - C++17</li>
</ul>
<p>берем expression, в котором фигурирует пакет и бинарным оператором его соединяем с многоточием. и это всё выполняется в compile time</p>
<pre><code class="language-cpp">template &lt;typename... Types&gt;
struct all_pointers {
    static constexpr bool value = (std::is_pointer_v&lt;Types&gt; &amp;&amp; ...);
    // обязательно скобки!
};
</code></pre>
<p>обозначает: для всех типов из пакета повторить <code>std::is_pointer_v</code> через конъюнкцию</p>
<ul>
<li><code>is_homogeneous</code></li>
</ul>
<pre><code class="language-cpp">template &lt;typename Head, typename... Tail&gt;
struct is_homogeneous {
    static constexpr bool value = (std::is_same_v&lt;Head, Tail&gt; &amp;&amp; ...);
};
</code></pre>
<p>проверяем, что Head равен всем в Tail</p>
<ul>
<li><code>print</code></li>
</ul>
<pre><code class="language-cpp">template &lt;typename... Types&gt;
void print(const Types&amp;... types) {
    (std::cout &lt;&lt; ... &lt;&lt; types);
    std::cout &lt;&lt; &quot;\n&quot;;
}

int main() {
    print();
    print(1, 2, &quot;sdf&quot;);
}
</code></pre>
<p>можно через пробел</p>
<pre><code class="language-cpp">template &lt;typename... Types&gt;
void print(const Types&amp;... types) {
    ((std::cout &lt;&lt; types &lt;&lt; ' '), ...);
    std::cout &lt;&lt; &quot;\n&quot;;
}

int main() {
    print();
    print(1, 2, &quot;sdf&quot;);
}
</code></pre>
<ul>
<li>как это раскрывается<br />
тут есть разная ассоциативность
<img src="lectures/img/33.png" alt="alt text" /></li>
</ul>
<h2><a class="header" href="#crtp---a-hrefhttpsruwikipediaorgwikicuriously_recurring_template_patterncuriously-recurring-template-patterna" id="crtp---a-hrefhttpsruwikipediaorgwikicuriously_recurring_template_patterncuriously-recurring-template-patterna">CRTP - <a href="https://ru.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curiously recurring template pattern</a></a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/crtp">cppreference</a></p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct Base {
    void interface() {
        // ...
        static_cast&lt;T*&gt;(this)-&gt;implementation();
        // ...
    }
    static void static_func() {
        // ...
        T::static_sub_func();
        // ...
    }
};

struct Derived : Base&lt;Derived&gt; {
    void implementation() {}
    static void static_sub_func() {}
};
</code></pre>
<p><code>Base</code> знает, что <code>T</code> это его потомок. благодаря этому, мы можем имитировать поведение виртуальных функций</p>
<p><code>interface()</code> определена у базового класса, но для разных <code>T</code> она себя ведёт по-разному.</p>
<p>в <code>Base</code> нельзя объявить объект типа <code>T</code> - получится циклическая зависимость. Но можно объявить <code>T*</code> или <code>T&amp;</code>.</p>
<p>функция <code>Base&lt;Derived&gt;::interface()</code> известна компилятору, хотя и объявлена перед объявлением структуры <code>struct Derived</code>. Тем не менее, эта функция не инстанцируется до момента фактического вызова, который должен произойти после объявления <code>Derived</code>.</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct Base {
    void interface() {
        static_cast&lt;T*&gt;(this)-&gt;implementation();
    }
};

struct A : Base&lt;A&gt; {
    void implementation() {
        std::cout &lt;&lt; &quot;A::implementation()&quot; &lt;&lt; std::endl;
    }
};
struct B : Base&lt;B&gt; {
    void implementation() {
        std::cout &lt;&lt; &quot;B::implementation()&quot; &lt;&lt; std::endl;
    }
};

template &lt;typename T&gt;
void f(Base&lt;T&gt;&amp; b) {
    b.interface();
}

int main() {
    A a;
    B b;
    f(a); // A::implementation()
    f(b); // B::implementation()
}
</code></pre>
<p>но это не совсем честный полиморфизм, потому что, например, нельзя сделать контейнер базового класса, в отличии от динамического полиморфизма</p>
<pre><code class="language-cpp">int main() {
    A a;
    B b;
    std::vector&lt;Base&lt;?&gt;&gt; v;
    v.push_back(a);
    v.push_back(b);
    for (auto obj : v) {
        obj.interface();
    }
}
</code></pre>
<h2><a class="header" href="#a-hrefhttpsenwikipediaorgwikiexpression_templatesexpression-templatesa" id="a-hrefhttpsenwikipediaorgwikiexpression_templatesexpression-templatesa"><a href="https://en.wikipedia.org/wiki/Expression_templates">Expression templates</a></a></h2>
<p>Способ создавать структуры, представляющие compile time вычисления, где выражения вычисляются по мере необходимости</p>
<p>Пример - складывание геометрических векторов. Если мы не хотим считать сумму векторов целиком, а только получить какой-то i-ый элемент (ленивое складывание)</p>
<p>Код можно посмотреть в википедии, не буду копировать его сюда</p>
<h2><a class="header" href="#Исключения" id="Исключения">Исключения</a></h2>
<ul>
<li><code>throw</code> - альтернативый способ выйти из функции на ряду с <code>return</code></li>
</ul>
<pre><code class="language-cpp">int divide(int a, int b) {
    if (b == 0) {
        throw std::logic_error(&quot;Divide by zero!&quot;);
    }
    return a / b;
}
</code></pre>
<p>происходит раскрутка стека. уничтожаются локальные переменные в порядке, обратном созданию (как и при обычном выходе из функции), и мы выскакиваем на уровень выше.</p>
<p>в какой момент это прекращается?</p>
<ul>
<li><code>try+catch</code> - ловим исключение</li>
</ul>
<pre><code class="language-cpp">try {
    divide(10, 0);
} catch (std::logic_error&amp; err) {
    std::cout &lt;&lt; err.what() &lt;&lt; std::endl;
}
</code></pre>
<p>исключение может прилететь и из глубины, если его ещё никто не поймал. есть будет подходящий catch, то мы поймаем исключение. ловить можно по значению, ссылке, константной </p>
<p>можно писать <code>catch(...)</code> - ловим любое исключение</p>
<p>исключения - очень тяжеловесная операция</p>
<ul>
<li>
<p>комментарий про раскручивание стека
<img src="lectures/img/36.png" alt="alt text" /></p>
</li>
<li>
<p>какие операторы стандартной библиотеки бросают исключения</p>
<ul>
<li><code>throw</code></li>
<li>оператор <code>new</code> - <code>std::bad_alloc</code></li>
</ul>
<pre><code>terminate called after throwing an instance of 'std::bad_alloc'
what():  std::bad_alloc
Aborted (core dumped)
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/error/terminate">std::terminate</a> - бросается рантаймом C++ если исключение брошено и не поймано (и много других пунктов)<br />
<a href="https://en.cppreference.com/w/cpp/utility/program/abort">std::abort</a> - бросается после terminate, просит ос убить программу с вердиктом abort (сишная функция)</p>
<ul>
<li><code>dynamic_cast</code> к ссылке - <code>std::bad_cast</code></li>
<li><code>typeid</code> от nullptr - <code>std::bad_typeid</code></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#Разница-между-исключением-и-runtime-error" id="Разница-между-исключением-и-runtime-error">Разница между исключением и runtime error</a></h2>
<ul>
<li>runtime error</li>
</ul>
<pre><code class="language-cpp">try {
    std::vector&lt;int&gt; v;
    v[1'000'000] = 1; // Segmentation fault (core dumped)
} catch(...) {
    std::cout &lt;&lt; &quot;Caught!\n&quot;;
}
</code></pre>
<pre><code class="language-cpp">int x; std::cin &gt;&gt; x;
try {
    std::cout &lt;&lt; 5/x; // Floating point exception (core dumped)
} catch(...) {
    std::cout &lt;&lt; &quot;Caught!\n&quot;;
}
</code></pre>
<p>это не плюсовый exception! это исключительная ситуация процессора</p>
<p><code>Segmentation fault</code>, <code>Floating point exception</code>, <code>Aborted</code> - виды RE, но далеко не все из них обусловлены плюсовыми exception. если падаем из-за плюсового exception, то низкоуровневая причина падения - <code>Aborted</code>.</p>
<p>плюсовые exception - уровень абстракции над этим всем. <code>std::runtime_error</code> - частный случай exception, который ничего не имеет общего с низкоуровнеывми RE ошибками</p>
<ul>
<li>иерархия исключений <a href="https://en.cppreference.com/w/cpp/error/exception">cppreference</a>
<img src="lectures/img/34.png" alt="alt text" /></li>
</ul>
<p>обычно, logic_error - ошибка, в которой виноват пользователь. runtime_error - что-то пошло не так</p>
<h1><a class="header" href="#a-hreflecturesraiitheoryhtmlЛекция-27a" id="a-hreflecturesraiitheoryhtmlЛекция-27a"><a href="lectures/../RAII/theory.html">Лекция 27</a></a></h1>
<p>более подробный текст по ссылке выше</p>
<ul>
<li>причины, почему программы падают
<img src="lectures/img/35.png" alt="alt text" /></li>
</ul>
<h2><a class="header" href="#exceptions-handling" id="exceptions-handling">Exceptions handling</a></h2>
<pre><code class="language-cpp">struct A {
    A() { std::cout &lt;&lt; &quot;A\n&quot;; }
    A(const A&amp;) { std::cout &lt;&lt; &quot;copy\n&quot;; }
    ~A() { std::cout &lt;&lt; &quot;~A\n&quot;; }
}; 

void f(int x) {
    A a;
    if (x == 0) {
        throw a;
    }
}

int main() {
    try {
        f(0);
    } catch (...) {
        std::cout &lt;&lt; &quot;caught!\n&quot;;
    }
}
</code></pre>
<p>объект скопируется в динамическую память (может быть в какую-то заранее выделенную статическую - это уже implementation defined) </p>
<pre><code>A
copy
~A
caught!
~A
</code></pre>
<p>если ловим по значению, будет ещё одно копирование - обратно на стек</p>
<pre><code class="language-cpp">try {
    f(0);
} catch (A a) {
    std::cout &lt;&lt; &quot;caught!\n&quot;;
}
</code></pre>
<pre><code>A
copy
~A
copy
caught!
~A
~A
</code></pre>
<p>по ссылке копирования не будет</p>
<ul>
<li><code>bad_alloc</code></li>
</ul>
<pre><code class="language-cpp">try{
    new int[400'000'000'000];
} catch (std::bad_alloc&amp; ex) {
    std::cout &lt;&lt; &amp;ex &lt;&lt; '\n';
}
</code></pre>
<p>под него резервируется память заранее в статической памяти (Emergency buffer)</p>
<ul>
<li><code>throw</code> внутри <code>catch</code></li>
</ul>
<pre><code class="language-cpp">try {
    f(0);
} catch (A&amp; a) {
    throw a; // старый объект а уничтожится, создаётся новый
}
</code></pre>
<p>но можно кинуть дальше (наверх!) тот же объект</p>
<pre><code class="language-cpp">try {
    f(0);
} catch (A&amp; a) {
    throw;
}
</code></pre>
<p>если делаем throw, дальнейшие catch того же уровня игнорируются, ловить будут только catch уровнем выше</p>
<pre><code class="language-cpp">try {
    try {
        f(0);
    } catch (A&amp; a) {
        std::cout &lt;&lt; &quot;caught!&quot; &lt;&lt; &amp;a &lt;&lt; '\n';
        throw;
    }
} catch (A&amp; a) {
    std::cout &lt;&lt; &quot;caught again!&quot; &lt;&lt; &amp;a &lt;&lt; '\n'; // такой же адрес
}
</code></pre>
<p>но если бы сделали <code>throw a;</code>, объект бы скопировался</p>
<ul>
<li>
<p>если исключение не ловится, то компилятор не гарантирует, что вызовутся деструкторы<br />
снова вставлю комментарий с прошлой лекции
<img src="lectures/img/36.png" alt="alt text" /></p>
</li>
<li>
<p>multiple catch</p>
</li>
</ul>
<p>для catch не применяются правила перегрузки, не делается выбор, какая конверсия лучше. ловится ровно тот тип, который мы указали</p>
<p>2 исключения:</p>
<ol>
<li>можно навесить <code>const</code></li>
<li>можно ловить наследника по ссылке на родителя, или по значению (срезка)</li>
</ol>
<p>нет никакой перегрузки, выбирается первый подходящий catch</p>
<pre><code class="language-cpp">struct Mom {};
struct Son : Mom {};

int main() {
    try {
        Son s;
        throw s; // caught Mom
    } catch (Mom) {
        std::cout &lt;&lt; &quot;caught Mom&quot;;
    } catch (Son) {
        std::cout &lt;&lt; &quot;caught Son&quot;;
    } catch (...) {
        std::cout &lt;&lt; &quot;other&quot;;
    }
}
</code></pre>
<p>но если наследование приватное, то выведется <code>caught Son</code>, из main не можем использовать тот факт, что сын наследник мамы</p>
<p>тут ещё бредовые примеры, про множественное наследование</p>
<h2><a class="header" href="#raii-resource-acquisition-is-initialization" id="raii-resource-acquisition-is-initialization">RAII (Resource Acquisition Is Initialization)</a></h2>
<p>рассмотрим проблему при владении ресурсом и исключениях</p>
<pre><code class="language-cpp">void g(int y) {
    if (y == 0) {
        throw 1;
    }
}

void f(int x) {
    int* p = new int(x);
    g(*p);
    delete p;
}
</code></pre>
<p>для решения воспользуемся тем, что в языке есть деструкторы - сделаем обертку, которая будет освобождать память в деструкторе. тогда не важно каким образом мы выйдем из функции, delete всё равно будет вызван. такая обертка называется умным указателем</p>
<p>его нельзя явно копировать, потому что появится проблема множественно владения ресурсом и double free</p>
<p>можно явно запретить копирование - получим <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a></p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct unique_ptr {
    T* p;
    unique_ptr(T* p): p(p) {}
    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
    ~unique_ptr() { delete p; }
    T&amp; operator*() {
        return *p;
    }
};
</code></pre>
<p>можно хранить счётчик ссылок - <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a></p>
<h2><a class="header" href="#Исключения-в-конструкторах" id="Исключения-в-конструкторах">Исключения в конструкторах</a></h2>
<pre><code class="language-cpp">struct A {
    A() { std::cout &lt;&lt; &quot;A&quot;; }
    ~A() { std::cout &lt;&lt; &quot;~A&quot;; }
};
struct S {
    A a;
    S(int x) {
        std::cout &lt;&lt; &quot;S&quot;;
        if (x == 0) throw 1;
    }
    ~S() { std::cout &lt;&lt; &quot;~S&quot;; }
};

int main() {
    try {
        S s(0);
    } catch (...) {}
}
</code></pre>
<p>вызовется деструктор A, т.к. оно уже успело создаться</p>
<pre><code>AS~A
</code></pre>
<p>но вот так будет утечка памяти</p>
<pre><code class="language-cpp">struct S {
    A* a;
    S(int x) : a(new A()) {
        std::cout &lt;&lt; &quot;S&quot;;
        if (x == 0) throw 1;
    }
    ~S() {
        std::cout &lt;&lt; &quot;~S&quot;;
        delete a;
    }
};
</code></pre>
<p>решение - RAII</p>
<ul>
<li>исключение в списке инициализации</li>
</ul>
<pre><code class="language-cpp">struct A {
    A(int x) {
        std::cout &lt;&lt; &quot;A&quot;;
        if (x == 0) throw 1;
    }
    ~A() {
        std::cout &lt;&lt; &quot;~A&quot;;
    }
};

struct S{
    A a;
    A aa;
    A aaa;
    S(int x) a(1), aa(0), aaa(2) {
        std::cout &lt;&lt; &quot;S&quot;;
    ~S(){
        std::cout &lt;&lt; &quot;~S&quot;;
    }
};
</code></pre>
<p>вызовутся деструкторы всех тех полей, которые успели создаться уже к этому моменту, то есть а(1)</p>
<ul>
<li>Function try block <a href="https://en.cppreference.com/w/cpp/language/try">cppreference</a></li>
</ul>
<pre><code class="language-cpp">struct S {
    A a;
    A aa;
    A aaa;
    S(int x) try : a(1), aa(0), aaa(2) {
        std::cout &lt;&lt; &quot;S&quot;;
    } catch (...) {
        std::cout &lt;&lt; &quot;caught!&quot;;
    }
    ~S(){
        std::cout &lt;&lt; &quot;~S&quot;;
    }
};
</code></pre>
<p>но что будет с таким объектом?</p>
<pre><code class="language-cpp">int main() {
    S s(0);
}
</code></pre>
<p>если мы написали такой function try block в конструкторе, то автоматически делается throw из него, поэтому в main прилетит исключение</p>
<p>такое можно писать для любой функции</p>
<pre><code class="language-cpp">void f() try {

} catch (...) {

}
</code></pre>
<h2><a class="header" href="#Исключения-в-деструкторах" id="Исключения-в-деструкторах">Исключения в деструкторах</a></h2>
<p>это зло!</p>
<p>проблема в том, что деструктор сам по себе мог быть вызван по причине того, что было брошено исключение</p>
<p>до C++11 нельзя бросать исключение из деструктора, если деструктор был вызван по причине летящего исключения. начиная с C++11 просто нельзя бросать исключение из деструктора (вызывается terminate)</p>
<p>можно разрешить с помощью <code>noexcept(false)</code></p>
<pre><code class="language-cpp">~S() noexcept(false) {
    std::cout &lt;&lt; &quot;~S&quot;;
    throw 1;
}
</code></pre>
<p>но, если деструктор вызван по причине того, что было брошено исключение, то всё равно произойдет terminate</p>
<pre><code class="language-cpp">try {
    S s(0);
    throw 1; // terminate
} catch(...) {}
</code></pre>
<p>как в деструкторе проверить, летит ли уже исключение?<br />
<a href="https://en.cppreference.com/w/cpp/error/uncaught_exception">std::uncaught_exception</a> (deprecated in C++17, removed in C++20)<br />
<a href="https://en.cppreference.com/w/cpp/error/uncaught_exception">std::uncaught_exceptions</a> (since C++17)</p>
<p>возможна ситуация, когда одновременно летит несколько exceptions</p>
<h1><a class="header" href="#Лекция-28" id="Лекция-28">Лекция 28</a></h1>
<h2><a class="header" href="#exception-safety" id="exception-safety">Exception safety</a></h2>
<p>есть 4 уровня безопасности относительно исключений (<a href="https://en.cppreference.com/w/cpp/language/exceptions">cppreference</a>):</p>
<ol>
<li>Nothrow (or nofail) exception guarantee — the function never throws exceptions.</li>
<li>Strong exception guarantee — If the function throws an exception, the state of the program is rolled back to the state just before the function call (for example, <a href="https://en.cppreference.com/w/cpp/container/vector/push_back">std::vector::push_back</a>). (большинство фукнций стандартных контейнеров)</li>
<li>Basic exception guarantee — If the function throws an exception, the program is in a valid state. No resources are leaked, and all objects' invariants are intact. </li>
<li>No exception guarantee — If the function throws an exception, the program may not be in a valid state: resource leaks, memory corruption, or other invariant-destroying errors may have occurred.</li>
</ol>
<p>Generic components may, in addition, offer exception-neutral guarantee: if an exception is thrown from a template parameter (e.g. from the Compare function object of std::sort or from the constructor of T in std::make_shared), it is propagated, unchanged, to the caller.</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/except_spec">Dynamic exception specification</a> (deprecated in C++11, removed in C++17)</li>
</ul>
<p>до C++11 можно было писать так</p>
<pre><code class="language-cpp">void f() throw {}
</code></pre>
<p>но сейчас так делать не надо</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/noexcept_spec">noexcept</a> (C++11) - спецификатор</li>
</ul>
<p>помечает функцию, как не кидающей исключение</p>
<pre><code class="language-cpp">void f() noexcept {

}
</code></pre>
<p>если мы пишем noexcept, то мы обещаем, что мы не будем бросать исключения из своей функции, но можно делать так</p>
<pre><code class="language-cpp">void f() noexcept try {

} catch (...) {

}
</code></pre>
<p>если из noexcept функции всё-таки брошено исключение, то произойдёт terminate</p>
<p>можно делать условный noexcept</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void f() noexcept(std::is_reference_v&lt;T&gt;) {
}
</code></pre>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/noexcept">noexcept</a> - оператор</li>
</ul>
<p>в compile time проверяет, является ли данное выражение noexcept</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void g() {}

int main(){
    std::cout &lt;&lt; noexcept(g&lt;int&gt;()); // 0
}
</code></pre>
<p>для функций проверяет, помечена ли она noexcept, для стандартных операторов noexcept являются все, кроме new, dynamic_cast, typeid, throw</p>
<p>так можно помечать функцию noexcept в зависимости от условия</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void g() {}

template &lt;typename T&gt;
void f() noexcept(noexcept(g&lt;T&gt;())) {
}
</code></pre>
<ul>
<li>смысл <code>noexcept</code></li>
</ul>
<p><code>operator[]</code> у вектора не noexcept, но он исключений не кидает</p>
<p>на самом деле, noexcept помечаются функции, которые в принципе не могут пойти неудачно. когда мы пишем noexcept или когда видим noexcept, то мы должны понимать это так, что ничего плохого не может произойти от вызова этого метода.</p>
<p>все деструкторы являются noexcept по умолчанию (С++11), этого слова явно не написано</p>
<h2><a class="header" href="#Внутреннее-устройство-vector" id="Внутреннее-устройство-vector">Внутреннее устройство vector</a></h2>
<p>сейчас нас интересует только реализация <code>push_back</code>, остальные методы реализуются просто</p>
<p>рассмотрим самую простую реализацию, используя только уже изученные инструменты (приближенно к C++03)</p>
<ul>
<li>1 проблема<br />
нужно научиться делать аллокацию, но не создавая объектов, сколько мы хотим</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
class vector {
    T* arr_;
    size_t sz_;
    size_t cap_;

public:
    void reserve(size_t newcap) {
        T* newarr = new T[newcap]; // вызываются конструкторы по умолчанию
        //...
    }

    void push_back(const T&amp; value) {
        if (sz_ == cap_) {
            reserve(cap_ &gt; 0 ? cap_ * 2 : 1);
        }
        //...
    }
};
</code></pre>
<p>такой код не работает для объектов, у которых нет конструктора по умолчанию</p>
<pre><code class="language-cpp">struct S {
    int x;
    S(int x) : x(x) {}
};
</code></pre>
<p>с нашим уровнем знаний нельзя написать ничего лучше</p>
<pre><code class="language-cpp">T* newarr = reinterpret_cast&lt;T*&gt;(new char[newcap * sizeof(T)]);
</code></pre>
<ul>
<li>2 проблема<br />
нужно скопировать объекты их старой памяти в новую. мы пытаемся сделать присваивание сырым байтам, под <code>newarr[index]</code> ещё нет никакого объекта</li>
</ul>
<pre><code class="language-cpp">void reserve(size_t newcap) {
    T* newarr = reinterpret_cast&lt;T*&gt;(new char[newcap * sizeof(T)]);
    for (size_t index = 0; index &lt; sz_; ++index) {
        newarr[index] = arr_[index]; // UB
    }
    //...
}
</code></pre>
<p>решение с <code>memcpy</code> не будет работать, если одно из полей объекта является указателем или ссылкой на другое его поле</p>
<pre><code class="language-cpp">struct Strange {
    int x;
    int&amp; r;
    Strange(int y) : x(y), r(x) {}
};
</code></pre>
<p>но такие объекты должны переживать реаллокацию<br />
спойлер: std::string является таким типом </p>
<p>нужно по данному адресу вызвать конструктор данного типа (на сырой памяти)<br />
решение: оператор <code>placement new</code> <a href="https://en.cppreference.com/w/cpp/language/new">cppreference</a></p>
<pre><code class="language-cpp">new(newarr + index) T(arr_[index]);
</code></pre>
<ul>
<li>3 проблема<br />
как вызвать деструкторы для объектов в старой памяти</li>
</ul>
<pre><code class="language-cpp">void reserve(size_t newcap) {
    T* newarr = reinterpret_cast&lt;T*&gt;(new char[newcap * sizeof(T)]);
    for (size_t index = 0; index &lt; sz_; ++index) {
        new(newarr + index) T(arr_[index]);
    }

    delete[] arr_; // удаляем массив char из newcap * sizeof(T) элементов
    //...
}
</code></pre>
<p>нужно руками вызвать деструкторы, и не только по этому. reserve можно вызывать не обязательно, когда sz == cap. можно сделать reserve, даже если массив не заполнен целиком. в этом случае нужно вызвать именно столько деструкторов, сколько было объектов</p>
<pre><code class="language-cpp">for (size_t index = 0; index &lt; sz_; ++index) {
    (arr_ + index)-&gt;~T();
}
delete[] reinterpret_cast&lt;char*&gt;(arr_);
</code></pre>
<p>по моему, можно сделать и так</p>
<pre><code class="language-cpp">arr_[index].~T();
</code></pre>
<ul>
<li>3 проблема - exception safety<br />
хотим безопасный относительно исключений reserve</li>
</ul>
<pre><code class="language-cpp">void reserve(size_t newcap) {
    if (newcap &lt; cap_) {
        return;
    }

    T* newarr = reinterpret_cast&lt;T*&gt;(new char[newcap * sizeof(T)]);
    for (size_t index = 0; index &lt; sz_; ++index) {
        new(newarr + index) T(arr_[index]);
    }

    for (size_t index = 0; index &lt; sz_; ++index) {
        (arr_ + index)-&gt;~T();
    }
    delete[] reinterpret_cast&lt;char*&gt;(arr_);
    
    arr_ = newarr;
    cap_ = newcap;
}
</code></pre>
<ol>
<li>если <code>new</code> кинет исключение, мы к этому моменту ещё ничего не испортили. так наверх и вылетим с исключением <code>std::bad_alloc</code></li>
<li><code>placement new</code> сам по себе не кидает исключение, но T может кинуть исключение в конструкторе. нужно удалить всё то, что мы успели скопировать</li>
<li>считаем, что деструкторы не кидают исключений</li>
<li><code>delete</code> тоже не кидает исключений</li>
</ol>
<pre><code class="language-cpp">void reserve(size_t newcap) {
    if (newcap &lt; cap_) {
        return;
    }

    T* newarr = reinterpret_cast&lt;T*&gt;(new char[newcap * sizeof(T)]);
    size_t index = 0;
    try {
        for (; index &lt; sz_; ++index) {
            new(newarr + index) T(arr_[index]);
        }
    } catch (...) {
        for (size_t oldindex = 0; oldindex &lt; index; ++oldindex) {
            (newarr + oldindex)-&gt;~T();
        }
        delete[] reinterpret_cast&lt;char*&gt;(newarr);
        throw;
    }

    for (size_t index = 0; index &lt; sz_; ++index) {
        (arr_ + index)-&gt;~T();
    }
    delete[] reinterpret_cast&lt;char*&gt;(arr_);
    
    arr_ = newarr;
    cap_ = newcap;
}
</code></pre>
<p>но ведь мы писали push_back</p>
<pre><code class="language-cpp">void push_back(const T&amp; value) {
    if (sz_ == cap_) {
        reserve(cap_ &gt; 0 ? cap_ * 2 : 1);
    }
    new(arr_ + sz_) T(value);
    ++sz_;
}
</code></pre>
<ol start="5">
<li>пытаемся положить на новое место новый элемент. а вдруг он кинет исключение. тогда надо всё вернуть как было.</li>
</ol>
<p>вывод: выражать push_back через reserve - плохая идея. нужно в том же блоке try пытаться положить новый элемент</p>
<h2><a class="header" href="#vectorbool" id="vectorbool"><code>vector&lt;bool&gt;</code></a></h2>
<p>there is one impostor among us</p>
<p>operator[] возвращает не ссылку, а новый временный объект bit_reference. и ему можно присваивать</p>
<pre><code class="language-cpp">std::vector&lt;bool&gt; v(10);
v[5] = true;
</code></pre>
<p>!пример ситуации, когда rvalue можно и нужно что-то присваивать</p>
<pre><code class="language-cpp">template &lt;&gt;
class vector&lt;bool&gt; {
    char* arr_ = nullptr;
    size_t sz_ = 0;
    size_t cap_ = 0;

    struct BitReference {
        char* cell;
        uint8_t index;

        BitReference(char* cell, uint8_t index)
            : cell(cell), index(index) {}

        BitReference operator=(bool b) {
            if (b) {
                *cell |= (1 &lt;&lt; index);
            } else {
                *cell &amp;= ~(1 &lt;&lt; index);
            }
            return *this;
        }

        operator bool() const {
            return *cell &amp; (1 &lt;&lt; index);
        }
    };
public:
    BitReference operator[](size_t index) {
        return BitReference(arr_ + index / 8, index % 8);
    }
};
</code></pre>
<p><a href="lectures/./code/lec28/vector.cpp">полный код с лекции</a></p>
<h1><a class="header" href="#Лекция-29" id="Лекция-29">Лекция 29</a></h1>
<p>опять немного про вектор</p>
<ul>
<li>инвалидация указателей/ссылок - UB<br />
<img src="lectures/img/37.png" alt="alt text" />
<img src="lectures/img/38.png" alt="alt text" /></li>
</ul>
<h2><a class="header" href="#Внутреннее-устройство-deque" id="Внутреннее-устройство-deque">Внутреннее устройство deque</a></h2>
<p>важное отличие <code>deque</code> от <code>vector</code> - он такими свойствами не обладает. это главное, почему он используется под капотом в <code>stack</code>, <code>queue</code>, <code>priority_queue</code></p>
<p>как реализовать такой контейнер?</p>
<ul>
<li>
<p>храним внешний массив указателей на T - buckets
<img src="lectures/img/39.png" alt="alt text" /></p>
</li>
<li>
<p>когда первый или последний слой заполнены, реаллоцируем внешний массив
<img src="lectures/img/40.png" alt="alt text" /></p>
</li>
<li>
<p>внутренние массивы так же являются сырыми байтами, кладем элементы через <code>placement new</code></p>
</li>
<li>
<p><code>operator[]</code> работает за <code>O(1)</code>, т.к. размер бакетов константный - это можно легко пересчитывать</p>
</li>
<li>
<p>у дека нет <code>reserve</code>, <code>shrink_to_fit</code></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/container/stack">std::stack</a>,
<a href="https://en.cppreference.com/w/cpp/container/queue">std::queue</a>, <a href="https://en.cppreference.com/w/cpp/container/priority_queue">std::priority_queue</a> по умолчанию работают над деком</p>
</li>
<li>
<p>почему в стеке <code>pop()</code> возвращает void а не T?<br />
чтобы возвращать T, его всегда нужно было бы куда-то скопировать</p>
</li>
</ul>
<h2><a class="header" href="#a-hreflecturesiteratorstheoryhtmlИтераторыa" id="a-hreflecturesiteratorstheoryhtmlИтераторыa"><a href="lectures/../iterators/theory.html">Итераторы</a></a></h2>
<p>более подробный текст по ссылке выше</p>
<p>не во всех контейнерах можно обращаться по индексу<br />
<a href="https://en.cppreference.com/w/cpp/iterator">итератор</a> - тип, который позволяет делать обход последовательности (обобщение указателя). его также можно разыменовывать и инкрементировать</p>
<ul>
<li>типы итераторов</li>
</ul>
<ol>
<li>Input Iterator<br />
<code>!=</code>, <code>-&gt;</code></li>
<li>Forward Iterator<br />
будем видеть одно и то же при проходах</li>
<li>Bidirectional Iterator<br />
<code>--</code></li>
<li>Random Access Iterator<br />
<code>+=n</code>, <code>-=n</code>, <code>it1-it2</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li>
<li>Contiguous Iterator (C++17)<br />
сплошной кусок памяти</li>
</ol>
<p>есть ещё <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">output_iterator</a> - в него можно писать, обсудим отдельно</p>
<p><img src="lectures/img/41.png" alt="alt text" /></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/range-for">range-based for</a></li>
</ul>
<pre><code class="language-cpp">std::set&lt;int&gt; s;
for (int x : s) {
    // x
}
</code></pre>
<p>означает</p>
<pre><code class="language-cpp">for (std::set&lt;int&gt;::iterator it = s.begin(); it != s.end(); ++it) {
    // *it
}
</code></pre>
<p>на самом деле не совсем так, он запоминает изначальные being и end перед циклом</p>
<ul>
<li><a href="https://cppinsights.io/">cppinsights.io</a> - сайт, который удаляет весь синтаксический сахар</li>
</ul>
<p>вот на самом деле, во что развернётся for из примера выше</p>
<pre><code class="language-cpp">#include &lt;set&gt;

int main()
{
  std::set&lt;int, std::less&lt;int&gt;, std::allocator&lt;int&gt; &gt; s = std::set&lt;int, std::less&lt;int&gt;, std::allocator&lt;int&gt; &gt;();
  {
    std::set&lt;int, std::less&lt;int&gt;, std::allocator&lt;int&gt; &gt; &amp; __range1 = s;
    std::_Rb_tree_const_iterator&lt;int&gt; __begin1 = __range1.begin();
    std::_Rb_tree_const_iterator&lt;int&gt; __end1 = __range1.end();
    for(; operator!=(__begin1, __end1); __begin1.operator++()) {
      int x = __begin1.operator*();
    }
    
  }
  return 0;
}
</code></pre>
<ul>
<li>
<p><a href="https://en.cppreference.com/w/cpp/named_req">Named Requirements</a> - некоторые свойства типов, которые формально описаны. в том числе, контейнеры и итераторы</p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/algorithm">Algorithms library</a> - алгоритмы стандартной библиотеки, работают с итераторами. название шаблонного параметра подсказывает нам, какой тип итератора нужен</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/sort">std::sort</a> требует Random Access Iterator</li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/next_permutation">std::next_permutation</a> требует Bidirectional Iterator</li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">std::lower_bound</a> нужен Forward Iterator. на самом деле бинпоиск работает логарифмическое время относительно операций над T (логарифмическое кол-во сравнений), сдвиги итератора не учитываются. для больших объектов (например, строки) может быть осмысленно сделать бинпоиск на связном списке, сэкономив кол-во вызовов операций сравнения. но для Random Access Iterator, оно будет делать <code>+=</code></li>
</ul>
</li>
<li>
<p>как по итератору, понять его вид?</p>
</li>
</ul>
<p>с C++11 есть <code>auto</code>, но это не всегда корректно</p>
<pre><code class="language-cpp">template &lt;typename InputIterator&gt;
void find_most_often_number(InputIterator begin, InputIterator end) {
    auto x = *begin;
    // ...
}
</code></pre>
<p>например, для <code>vector&lt;bool&gt;</code> это bit_reference</p>
<p>есть набор метафункций для итераторов - <a href="https://en.cppreference.com/w/cpp/iterator/iterator_traits">std::iterator_traits</a></p>
<p>можно узнать тип</p>
<pre><code class="language-cpp">template &lt;typename InputIterator&gt;
void find_most_often_number(InputIterator begin, InputIterator end) {
    typename std::iterator_traits&lt;InputIterator&gt;::value_type x = *begin;
}

int main() {
    std::vector&lt;bool&gt; vb(10);
    find_most_often_number(vb.begin(), vb.end());
}
</code></pre>
<p>также можно узнать, какая категория итератора <a href="https://en.cppreference.com/w/cpp/iterator/iterator_tags">iterator_category</a> - пустые структуры (теги). они сделаны с наследованием для удобства проверки на равентсво категорий итератора</p>
<h1><a class="header" href="#Лекция-30" id="Лекция-30">Лекция 30</a></h1>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/iterator/distance">std::distance</a> - количество шагов от first до last<br />
если Random Access Iterator, то она работает за константное время, иначе за линейное</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/types/is_base_of">std::is_base_of</a> - является ли родителем</p>
<pre><code class="language-cpp">template &lt;typename Iterator&gt;
typename std::iterator_traits&lt;Iterator&gt;::difference_type
distance(Iterator first, Iterator last) {
    if constexpr (std::is_base_of_v&lt;
        std::random_access_iterator_tag,
        typename std::iterator_traits&lt;Iterator&gt;::iterator_category
    &gt;) {
        return last - first;
    } else {
        int i = 0;
        for (; first != last; ++first) {
            ++i;
        }
        return i;
    }
}

int main() {
    std::vector&lt;bool&gt; vb(10);
    std::cout &lt;&lt; ::distance(vb.begin(), vb.end());
}
</code></pre>
<p>можно без <code>if constexpr</code> средставми старого C++, но более костыльно - через перегрузку функций</p>
<ul>
<li>
<p><a href="https://en.cppreference.com/w/cpp/iterator/advance">std::advance</a> - двигает итератор на n шагов</p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/iterator/prev">std::prev</a>, <a href="https://en.cppreference.com/w/cpp/iterator/next">std::next</a> - двигает назад или вперёд на n шагов и возвращает итератор</p>
</li>
</ul>
<h2><a class="header" href="#Реализация-итераторов" id="Реализация-итераторов">Реализация итераторов</a></h2>
<p>будем дописывать <a href="lectures/./code/lec28/vector.cpp">код вектора</a>
с 28 лекции</p>
<pre><code class="language-cpp">class iterator {
    T* ptr;

    iterator(T* ptr) : ptr(ptr) {}
public:
    iterator(const iterator&amp;) = default;
    iterator&amp; operator=(const iterator&amp;) = default;

    T&amp; operator*() const { return *ptr; }
    T* operator-&gt;() const { return ptr; } // вот такой костыль языка

    iterator&amp; operator++() {
        ++ptr;
        return *this;
    }
    iterator&amp; operator++(int) {
        iterator copy = *this;
        ++ptr;
        return copy;
    }
};
</code></pre>
<p>здесь под const iterator - подразумевается аналог константного указателя (поэтому <code>operator*</code> и <code>operator-&gt;</code> помечены const, но возвращают обычную ссылку! на T)</p>
<ul>
<li>const_iterator - аналог указателя на const<br />
он уже возвращает const ссылку на T</li>
</ul>
<pre><code class="language-cpp">class const_iterator {
    const T* ptr;

    const_iterator(T* ptr) : ptr(ptr) {}
public:
    const_iterator(const const_iterator&amp;) = default;
    const_iterator&amp; operator=(const const_iterator&amp;) = default;

    const T&amp; operator*() const { return *ptr; }
    const T* operator-&gt;() const { return ptr; }

    const_iterator&amp; operator++() {
        ++ptr;
        return *this;
    }
    const_iterator&amp; operator++(int) {
        const_iterator copy = *this;
        ++ptr;
        return copy;
    }
};
</code></pre>
<p>но как не копипастить это 2 раза?</p>
<pre><code class="language-cpp">template &lt;bool IsConst&gt;
class base_iterator {
public:
    using pointer_type = std::conditional_t&lt;IsConst, const T*, T*&gt;;
    using reference_type = std::conditional_t&lt;IsConst, const T&amp;, T&amp;&gt;;
    using value_type = T;

private:
    pointer_type ptr;
    base_iterator(T* ptr) : ptr(ptr) {}

    friend class vector&lt;T&gt;;
public:
    base_iterator(const base_iterator&amp;) = default;
    base_iterator&amp; operator=(const base_iterator&amp;) = default;

    reference_type operator*() const { return *ptr; }
    pointer_type operator-&gt;() const { return ptr; }

    base_iterator&amp; operator++() {
        ++ptr;
        return *this;
    }
    base_iterator&amp; operator++(int) {
        base_iterator copy = *this;
        ++ptr;
        return copy;
    }

    operator base_iterator&lt;true&gt;() const {
        return {ptr};
    }
};
</code></pre>
<p>последний итератор разрешает неявно кастоваться от неконстантного итератора к константному</p>
<p>затем в публичной части</p>
<pre><code class="language-cpp">using iterator = base_iterator&lt;false&gt;;
using const_iterator = base_iterator&lt;true&gt;;

iterator begin() { return {arr_}; }
iterator end() { return {arr_ + sz_}; }

const_iterator begin() const { return {arr_}; }
const_iterator end() const { return {arr_ + sz_}; }
</code></pre>
<p>но есть ещё <code>cbegin</code>, <code>cend</code> - одинаковый для константного и неконстантного контейнера</p>
<pre><code class="language-cpp">const_iterator cbegin() const { return {arr_}; }
const_iterator cend() const { return {arr_ + sz_}; }
</code></pre>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator">std::reverse_iterator</a> - отдельный класс в стандартной библиотеке</li>
</ul>
<p>это адаптер над итератором, он хранит в себе итератор и разворачивает все действия в обратную сторону</p>
<p><img src="lectures/img/42.png" alt="alt text" /></p>
<p>т.е. <code>++</code> это <code>--</code> и наоборот, <code>*</code> или <code>-&gt;</code> это <code>current - 1</code></p>
<p>так же раньше был <a href="https://en.cppreference.com/w/cpp/iterator/iterator">std::iterator</a> (deprecated in C++17) - это другое, им не надо пользоваться (итераторы, это внутренние типы контейнеров!)</p>
<p>поэтому напишем</p>
<pre><code class="language-cpp">using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;
using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;
</code></pre>
<p><code>rbegin</code>, <code>rend</code>, <code>crbegin</code>, <code>crend</code> добавятся сами</p>
<ul>
<li>инвалидация итераторов<br />
аналогично - UB</li>
</ul>
<pre><code class="language-cpp">std::vector&lt;int&gt; v(10);
std::vector&lt;int&gt;::iterator x = v.begin() + 5;
v.push_back(1);
std::cout &lt;&lt; *x;
</code></pre>
<p>соответственно это тоже UB</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};
for (int&amp; x : v) {
    v.push_back(x);
}
</code></pre>
<p>даже не смотря на то, что <code>begin</code> и <code>end</code> запоминаются заранее, вектор может сделать реаллокацию в теле цикла, и старые итераторы инвалидируются</p>
<ul>
<li>fun fact</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/container/vector/swap">одно из свойств итератора вектора</a>, что мы должны уметь свапать векторы, но при этом чтобы итераторы сохранялись валидными</p>
<p>в деке указатели и ссылки не инвалидируются, но итераторы инвалидируются (нужно хранить указатель на элемент внешнего массива, но внешний массив может реаллоцироваться при <code>push_back</code>)</p>
<p><a href="lectures/./code/lec30/vector.cpp">итоговый код vector</a></p>
<h2><a class="header" href="#output-iterator" id="output-iterator">Output iterator</a></h2>
<pre><code class="language-cpp">int a[10] = {1, 2, 3, 4, 5};
std::vector&lt;int&gt; v(5);
std::copy(a, a + 10, v.begin()); // UB
</code></pre>
<p><code>copy</code> разыменовывает, присваивает и инкрементирует. он ничего не знает про то, что лежит под итератором</p>
<ul>
<li>
<p><code>output iterator</code> гарантирует, что можно его разыменовывать, инкрементировать и присваивать сколько угодно раз</p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/iterator/back_insert_iterator">std::back_insert_iterator</a> - output итератор, который докладывает элементы в контейнер, для которого он сконструирован</p>
</li>
</ul>
<pre><code class="language-cpp">int a[10] = {1, 2, 3, 4, 5};
std::vector&lt;int&gt; v;
std::copy(a, a + 5, std::back_insert_iterator&lt;std::vector&lt;int&gt;&gt;(v));
for (int x : v) {
    std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; // 1 2 3 4 5
}
</code></pre>
<p>как его реализовать?</p>
<pre><code class="language-cpp">template &lt;typename Container&gt;
class back_insert_iterator {
    Container&amp; container;
public:
    back_insert_iterator(Container&amp; container) : container(container) {}

    back_insert_iterator&amp; operator=(const typename Container::value_type&amp; value) {
        container.push_back(value);
        return *this;
    }
    back_insert_iterator&amp; operator++() { return *this; }
    back_insert_iterator operator++(int) { return *this; }
    back_insert_iterator&amp; operator*() { return *this; }
};
</code></pre>
<p>также есть функция <a href="https://en.cppreference.com/w/cpp/iterator/back_inserter">std::back_inserter</a>, которая просто создаёт такой итератор, без указания шаблонного параметра</p>
<pre><code class="language-cpp">template&lt;class Container&gt;
std::back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; c)
{
    return std::back_insert_iterator&lt;Container&gt;(c);
}
</code></pre>
<pre><code class="language-cpp">std::copy(a, a + 5, std::back_inserter(v));
</code></pre>
<p>также есть <a href="https://en.cppreference.com/w/cpp/iterator/front_inserter">std::front_inserter</a> и <a href="https://en.cppreference.com/w/cpp/iterator/inserter">std::inserter</a></p>
<p><a href="https://en.cppreference.com/w/cpp/iterator/insert_iterator">std::insert_iterator</a> принимает контейнер и итератор в контейнере, вызывает insert в этом контейнере, по данному итератору</p>
<h1><a class="header" href="#Лекция-31-34" id="Лекция-31-34">Лекция 31-34</a></h1>
<p>TODO</p>
<h1><a class="header" href="#Лекция-35" id="Лекция-35">Лекция 35</a></h1>
<h2><a class="header" href="#Аллокаторы" id="Аллокаторы">Аллокаторы</a></h2>
<p>идея: пусть у нас есть <code>list</code> на миллион интов. на каждый <code>insert</code> вызывается оператор <code>new</code>. так же с <code>map</code>, <code>set</code>, <code>unordered_set</code>. очевидно, что это работает медленно</p>
<p>почему бы, например, не завести этот <code>list</code> на стеке, если он туда спокойно поместится?</p>
<p>аллокатор - прослойка между контейнером и оператором <code>new</code></p>
<p><code>Container -&gt; Allocator -&gt; operator new -&gt; malloc -&gt; OS</code><br />
алгоритм, который реализован в функции malloc, тоже иногда называется аллокатором. и его тоже можно заменить (аллокаторы уровня C). но мы рассматриваем аллокаторы уровня C++</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/memory/allocator">std::allocator</a></li>
</ul>
<p>наивная реализация</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct allocator {
    T* allocate(size_t count) {
        return reinterpret_cast&lt;T*&gt;(new char[count * sizeof(T)]);
    }

    void deallocate(T* ptr, size_t) {
        delete[] reinterpret_cast&lt;char*&gt;(ptr);
    }

    template &lt;typename U, typename... Args&gt;
    void construct(U* ptr, const Args&amp;... args) {
        new (ptr) U(args...);
    }

    template &lt;typename U&gt;
    void destroy(U* ptr) {
        ptr-&gt;~U();
    }
    // объяснение насчет шаблонного U будет позже
};
</code></pre>
<p>это не совсем правда, в дальейшем мы будем её улучшать</p>
<ul>
<li>теперь исправим <a href="lectures/./code/lec30/vector.cpp">код вектора</a> с 30 лекции</li>
</ul>
<p>теперь вектор принимает аллокатор вторым шаблонным параметром</p>
<pre><code class="language-cpp">template &lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt;
class vector {
    T* arr_ = nullptr;
    size_t sz_ = 0;
    size_t cap_ = 0;
    Alloc alloc_;
    // ...
};
</code></pre>
<p>вот как поменяется метод <code>reserve</code></p>
<pre><code class="language-cpp">void reserve(size_t newcap) {
    if (newcap &lt; cap_) {
        return;
    }

    // T* newarr = reinterpret_cast&lt;T*&gt;(new char[newcap * sizeof(T)]);
    T* newarr = alloc_.allocate(newcap);
    size_t index = 0;
    try {
        for (; index &lt; sz_; ++index) {
            // new(newarr + index) T(arr_[index]);
            alloc_.construct(newarr + index, arr_[index]);
        }
    } catch (...) {
        for (size_t oldindex = 0; oldindex &lt; index; ++oldindex) {
            // (newarr + oldindex)-&gt;~T();
            alloc_.destroy(newarr + oldindex);
        }
        // delete[] reinterpret_cast&lt;char*&gt;(newarr);
        alloc_.deallocate(newarr, newcap);
        throw;
    }

    for (size_t index = 0; index &lt; sz_; ++index) {
        // (arr_ + index)-&gt;~T();
        alloc_.destroy(arr_ + index);
    }
    // delete[] reinterpret_cast&lt;char*&gt;(arr_);
    alloc_.deallocate(arr_, cap_);
    
    arr_ = newarr;
    cap_ = newcap;
}
</code></pre>
<ul>
<li>
<p>конструкторы стандартных контейнеров обычно принимают аллокатор</p>
</li>
<li>
<p>дефолтный конструктор вектора помечен <code>noexcept(noexcept(Allocator()))</code></p>
</li>
<li>
<p>стандартные аллокаторы равны</p>
</li>
<li>
<p>у контейнеров есть метод <code>get_allocator</code> - возвращает копию текущего аллокатора (аллокатор - всегда маленький объект)</p>
</li>
<li>
<p>примеры нестандартных аллокаторов</p>
<ol>
<li>PoolAllocator - изначально выделаем массив и выдаём кусочки</li>
<li>StackAllocator - выделаяет всё на стеке, в констукторе принимаем массив, например как-то так:
<pre><code class="language-cpp">std::array&lt;char, 1000000&gt; arr;
StackAllocator alloc(arr);
std::list&lt;int, StackAllocator&lt;int&gt;&gt; lst;
</code></pre>
</li>
<li>FreeListAllocator - изначально выделяем объекты как обычно. а когда освобождаем, сохраняем их в свой список свободных кусков памяти, и в следующие разы бёрем оттуда</li>
</ol>
</li>
</ul>
<h2><a class="header" href="#Проблемы" id="Проблемы">Проблемы</a></h2>
<ul>
<li>не всем контейнерам нужно аллоцировать тот тип <code>T</code>, от которого был создан аллокатор. например <code>list</code> и <code>map</code> должны аллоцировать некий <code>Node</code>, но пользователь про него ничего не знает, это приватный тип</li>
</ul>
<p>начнем релизовывать list</p>
<pre><code class="language-cpp">template &lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt;
class list {
    struct BaseNode {
        BaseNode* prev;
        BaseNode* next;
    };

    struct Node {
        T value;
    };

    BaseNode fakeNode;
    size_t count;
    Alloc/*???*/ alloc;
};
</code></pre>
<p>хотим иметь аллокатор на <code>Node</code>, но мы не можем его объявить, мы даже не можем назвать его тип</p>
<ul>
<li>костыль такой:<br />
в аллокаторе есть метафункция (структура), которая позволяет получить такой же аллокатор, но другого <code>T</code> - <code>rebind</code></li>
</ul>
<p>в <a href="https://en.cppreference.com/w/cpp/memory/allocator">std::allocator</a> она (deprecated in C++17, removed in C++20)</p>
<pre><code class="language-cpp">template &lt;typename U&gt;
struct rebind {
    using other = allocator&lt;U&gt;;
};
</code></pre>
<p>теперь можем использовать этот тип</p>
<pre><code class="language-cpp">template &lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt;
class list {
    struct BaseNode {
        BaseNode* prev;
        BaseNode* next;
    };

    struct Node {
        T value;
    };

    BaseNode fakeNode;
    size_t count;
    typename Alloc::rebind&lt;Node&gt;::other alloc;
};
</code></pre>
<p>clang подсказывает исправить dependent template name, хотя g++ компилирует</p>
<pre><code class="language-cpp">typename Alloc::template rebind&lt;Node&gt;::other alloc;
</code></pre>
<ul>
<li>теперь как инициализировать этот аллокатор?</li>
</ul>
<pre><code class="language-cpp">list(const Alloc&amp; alloc) : fakeNode{}, count(), alloc(/*???*/)
</code></pre>
<p>надо добавить в аллокатор конструктор от аллокатора того же типа, с другим любым шаблонным параметром</p>
<pre><code class="language-cpp">template &lt;typename U&gt;
allocator(allocator&lt;U&gt;) {}
</code></pre>
<p>теперь можно спокойно написать</p>
<pre><code class="language-cpp">list(const Alloc&amp; alloc) : fakeNode{}, count(), alloc(alloc) {}
</code></pre>
<ul>
<li>
<p>теперь понятно, почему изначально <code>construct</code> принимал произвольный тип <code>U</code> в качестве шаблонного<br />
пример - когда мы аллоцировали <code>Node</code>, но надо вызвать <code>construct</code> для типа <code>T</code>. аналогично с <code>destroy</code></p>
</li>
<li>
<p>почему аллокатор не может быть шаблонным шаблонным параметром?</p>
</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T, template&lt;typename&gt; Alloc = std::allocator&gt;
class list {
    //...
    Alloc&lt;Node&gt; alloc;
    //...
};
</code></pre>
<p>ответ: у аллокатора могут быть другие шаблонные параметры, не факт что он всегда один, и не факт, что это всегда будут типы<br />
например</p>
<pre><code class="language-cpp">std::array&lt;char, 1000000&gt; arr;
StackAllocator&lt;int, 1000000&gt; alloc(arr);
</code></pre>
<ul>
<li>аллокатор не влияет на размер контейнера
сейчас sizeof нашего вектора 32, но можно сделать empty base optimization - наследуемся от аллокатора</li>
</ul>
<pre><code class="language-cpp">class vector : private Alloc {
    T* arr_ = nullptr;
    size_t sz_ = 0;
    size_t cap_ = 0;
    //...
};
</code></pre>
<p>теперь sizeof равен 24</p>
<h2><a class="header" href="#stateful-аллокаторы" id="stateful-аллокаторы">Stateful аллокаторы</a></h2>
<ul>
<li>копирование аллокаторов<br />
рассмотрим PoolAllocator, который хранит большой массив в динамической памяти.</li>
</ul>
<p>при копировании мы хотим, чтобы новый аллокатор ссылался на тот же массив, но не копировал его</p>
<p>возникает проблема общего владения памятью. одно из решений - <code>shared_ptr</code></p>
<p>можно сделать отдельный класс pool, в котором заниматься обработкой этого массива и сам pool вообще запретить копировать, а аллокатору хранить указатель на этот pool</p>
<h2><a class="header" href="#a-hrefhttpsencppreferencecomwcppmemoryallocator_traitsallocator_traitsa" id="a-hrefhttpsencppreferencecomwcppmemoryallocator_traitsallocator_traitsa"><a href="https://en.cppreference.com/w/cpp/memory/allocator_traits">allocator_traits</a></a></h2>
<p>у разных аллокаторов многие методы выглядят одинаково</p>
<p>было бы удобно иметь структуру, которая бы предопределяла некоторые функции и некоторые using-и</p>
<p><code>allocator_traits</code> за нас определяет функцию <code>construct</code>, <code>destroy</code>, структуру <code>rebind</code>, если у нас их нет</p>
<p>эти методы статические, сам объект <code>allocator_traits</code> мы никогда не создаём</p>
<p>мы пока не умеем такое писать</p>
<pre><code class="language-cpp">template &lt;typename Alloc&gt;
struct allocator_traits {
    template &lt;typename U, typename... Args&gt;
    static void construct(Alloc&amp; alloc, U* ptr, const Args&amp;... args) {
        if constexpr (/* Alloc has method construct */) {
            alloc.construct(ptr, args...);
        } else {
            new (ptr) U(args...);
        }
    }
};
</code></pre>
<p>аналогично для <code>destroy</code> и <code>rebind</code> (здесь это будет называться <code>rebind_alloc</code>)</p>
<p>также есть <code>allocate</code> и <code>deallocate</code> - просто для симметрии. поэтому контейнеры на самом деле, обращаются к <code>allocator_traits</code>, а не к аллокатору напрямую</p>
<p>поэтому наша исходная схема выглядит так:<br />
<code>Container -&gt; allocator_traits -&gt; Allocator -&gt; operator new -&gt; malloc -&gt; OS</code></p>
<p><a href="lectures/./code/lec35/allocator.cpp">итоговый код allocator</a><br />
<a href="lectures/./code/lec35/vector_ebo.cpp">итоговый код vector</a> (сделал сразу с ebo)<br />
<a href="lectures/./code/lec35/list.cpp">итоговый код list</a></p>
<h1><a class="header" href="#Лекция-36" id="Лекция-36">Лекция 36</a></h1>
<p>перепишем код вектора с использованием allocator_traits</p>
<pre><code class="language-cpp">void reserve(size_t newcap) {
    if (newcap &lt; cap_) {
        return;
    }

    T* newarr = AllocTraits::allocate(alloc_, newcap);
    size_t index = 0;
    try {
        for (; index &lt; sz_; ++index) {
            AllocTraits::construct(alloc_, newarr + index, arr_[index]);
        }
    } catch (...) {
        for (size_t oldindex = 0; oldindex &lt; index; ++oldindex) {
            AllocTraits::destroy(alloc_, newarr + oldindex);
        }
        AllocTraits::deallocate(alloc_, newarr, newcap);
        throw;
    }

    for (size_t index = 0; index &lt; sz_; ++index) {
        AllocTraits::destroy(alloc_, arr_ + index);
    }
    AllocTraits::deallocate(alloc_, arr_, cap_);
    
    arr_ = newarr;
    cap_ = newcap;
}
</code></pre>
<h2><a class="header" href="#a-hrefhttpsencppreferencecomwcppnamed_reqallocatorawarecontainerallocator-aware-контейнерыa-c11" id="a-hrefhttpsencppreferencecomwcppnamed_reqallocatorawarecontainerallocator-aware-контейнерыa-c11"><a href="https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer">Allocator-aware контейнеры</a> (C++11)</a></h2>
<p>когда контейнер копируется, должен ли он копировать аллокатор?</p>
<p>иногда нам бы хотелось, чтобы контейнер копировал аллокатор, а иногда, чтобы он создавал новый</p>
<ul>
<li>
<p>контейнер при копировании, спрашивает у аллокатора, что с ним делать. у аллокатора есть опциональный метод <code>select_on_container_copy_construction</code> - возвращает аллокатор по значению, если его нет <code>allocator_traits</code> доопределит его за нас</p>
</li>
<li>
<p>аналогично для присваивания - <code>propagate_on_container_copy_assignment</code>, только это метафункция (true или false в compile time)</p>
</li>
<li>
<p>реализация оператора присваивания для вектора<br />
пока наивная реализация, без присваивания аллокатора</p>
</li>
</ul>
<pre><code class="language-cpp">vector&amp; operator=(const vector&amp; other) {
    if (this == &amp;other) {
        return *this;
    }

    T* newarr = AllocTraits::allocate(alloc_, other.cap_);
    size_t i = 0;
    try {
        for (; i &lt; other.sz_; ++i) {
            AllocTraits::construct(alloc_, newarr + i, other[i]);
        }
    } catch(...) {
        for (size_t j = 0; j &lt; i; ++j) {
            AllocTraits::destroy(alloc_, newarr + j);
        }
        AllocTraits::deallocate(alloc_, newarr, other.cap_);
        throw;
    }

    for (size_t i = 0; i &lt; sz_; ++i) {
        AllocTraits::destroy(alloc_, arr_ + i);
    }
    AllocTraits::deallocate(alloc_, arr_, cap_);

    arr_ = newarr;
    sz_ = other.sz_;
    cap_ = other.cap_;
    return *this;
}
</code></pre>
<p>сейчас аллокатор намертво привязан к контейнеру. но хотим учитывать возможность забрать себе аллокатор</p>
<p>проблема - старые объекты нужно удалять старым аллокатором, а новые создавать новым. но при этом всё еще старые объекты нужно удалить позже, чтобы не нарушать exception safety</p>
<pre><code class="language-cpp">vector&amp; operator=(const vector&amp; other) {
    if (this == &amp;other) {
        return *this;
    }
    Alloc newalloc = AllocTraits::propagate_on_container_copy_assignment::value
        ? other.alloc_ : alloc_;

    T* newarr = AllocTraits::allocate(newalloc, other.cap_);
    size_t i = 0;
    try {
        for (; i &lt; other.sz_; ++i) {
            AllocTraits::construct(newalloc, newarr + i, other[i]);
        }
    } catch(...) {
        for (size_t j = 0; j &lt; i; ++j) {
            AllocTraits::destroy(newalloc, newarr + j);
        }
        AllocTraits::deallocate(newalloc, newarr, other.cap_);
        throw;
    }

    for (size_t i = 0; i &lt; sz_; ++i) {
        AllocTraits::destroy(alloc_, arr_ + i);
    }
    AllocTraits::deallocate(alloc_, arr_, cap_);

    arr_ = newarr;
    sz_ = other.sz_;
    cap_ = other.cap_;
    alloc_ = newalloc;
    return *this;
}
</code></pre>
<p>оператор присваивания аллокатора не должен кидать исключение - требование аллокатора (однако такого на cppreference не нашлось)</p>
<p>на самом деле, если новый аллокатор равен старому, то нет смысла присваивать новый аллокатор и выделять новую память. надо посмотреть, не хватает ли нам нашей текущей памяти (дописывать не стали)</p>
<ul>
<li>еще в аллокаторах есть метафункция <code>is_always_equal</code> - в compile time проверяем, правда ли что все аллокаторы такого типа равны<br />
(C++11, deprecated in C++23, removed in C++26)</li>
</ul>
<h2><a class="header" href="#Перегрузка-new-и-delete" id="Перегрузка-new-и-delete">Перегрузка new и delete</a></h2>
<p>можно глобально подменить операторы <code>new</code> и <code>delete</code>. это более низкоуровневая вещь, чем переопределение аллокаторов</p>
<ul>
<li>оператор <code>new</code> состоит из 2 частей:
<ol>
<li>выделение памяти - фунция <code>operator new</code></li>
<li>вызов конструктора на выделенной памяти - <code>placement new</code></li>
</ol>
</li>
</ul>
<p>на самом деле оператор <code>new</code> и функция <code>operator new</code> это 2 разных вещи. перегрузить можно только функцию <code>operator new</code>!!!</p>
<p>с <code>delete</code> всё наоборот</p>
<pre><code class="language-cpp">void* operator new(size_t n) {
    std::cout &lt;&lt; n &lt;&lt; &quot; bytes allocated\n&quot;;
    return malloc(n);
}

void operator delete(void* ptr) {
    free(ptr);
}

int main() {
    std::vector&lt;int&gt; v;
    for (int i = 0; i &lt; 50; ++i) {
        v.push_back(i);
    }
}
</code></pre>
<pre><code>4 bytes allocated
8 bytes allocated
16 bytes allocated
32 bytes allocated
64 bytes allocated
128 bytes allocated
256 bytes allocate
</code></pre>
<ul>
<li>аналогично можно сделать для <code>new[]</code> и <code>delete[]</code></li>
</ul>
<pre><code class="language-cpp">void* operator new[](size_t n) {
    std::cout &lt;&lt; n &lt;&lt; &quot;[] bytes allocated\n&quot;;
    return malloc(n);
}

void operator delete[](void* ptr) {
    free(ptr);
}

int main() {
    int* ptr = new int[100]; // 400[] bytes allocated
    delete[] ptr;
}
</code></pre>
<p>заметим, что в функцию пришел именно размер в байтах</p>
<p>но изначально <code>new[]</code> вызывает в себе <code>new</code>. поэтому, если его не определить, будет вот так</p>
<pre><code class="language-cpp">void* operator new(size_t n) {
    std::cout &lt;&lt; n &lt;&lt; &quot; bytes allocated\n&quot;;
    return malloc(n);
}

void operator delete(void* ptr) {
    free(ptr);
}

int main() {
    int* ptr = new int[100]; // 400 bytes allocated
    delete[] ptr;
}
</code></pre>
<ul>
<li>исправим код аллокатора</li>
</ul>
<p>можно вызывать не оператор <code>new</code>, в функцию <code>operator new</code></p>
<pre><code class="language-cpp">T* allocate(size_t count) {
    // return reinterpret_cast&lt;T*&gt;(new char[count * sizeof(T)]);
    return operator new(count * sizeof(T));
}

void deallocate(T* ptr, size_t) {
    // delete[] reinterpret_cast&lt;char*&gt;(ptr);
    operator delete(ptr);
}
</code></pre>
<p>эта функция <code>operator new</code> отрабатывает, как первая половина оператора <code>new</code></p>
<ul>
<li>как оператор <code>delete[]</code> понимает, сколько вызвать деструкторов? </li>
</ul>
<pre><code class="language-cpp">void* operator new(size_t n) {
    std::cout &lt;&lt; n &lt;&lt; &quot; bytes allocated\n&quot;;
    return malloc(n);
}

void operator delete(void* ptr) {
    free(ptr);
}

int main() {
    std::cout &lt;&lt; sizeof(std::string) &lt;&lt; &quot;\n&quot;;
    std::string* ps = new std::string[10];
    delete[] ps;
}
</code></pre>
<p>почему выделилось больше байт?</p>
<pre><code class="language-cpp">32
328 bytes allocated
</code></pre>
<p>когда мы выделяем нетривиальные типы, оператору <code>new[]</code> нужно записать, сколько штук их было, чтобы <code>delete[]</code> знал, сколько деструкторов вызвать</p>
<p>поэтому <code>operator delete[]</code> неявно за нас делает сдвиг на 8 байт</p>
<p>не нужно руками вызывать деструктор </p>
<p><a href="lectures/./code/lec36/allocator.cpp">итоговый код allocator</a><br />
<a href="lectures/./code/lec36/vector.cpp">итоговый код vector</a></p>
<h1><a class="header" href="#Лекция-37" id="Лекция-37">Лекция 37</a></h1>
<h2><a class="header" href="#a-hrefhttpsencppreferencecomwcppmemorynewoperator_newВерсии-оператора-newa" id="a-hrefhttpsencppreferencecomwcppmemorynewoperator_newВерсии-оператора-newa"><a href="https://en.cppreference.com/w/cpp/memory/new/operator_new">Версии оператора new</a></a></h2>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/memory/new/nothrow">std::nothrow_t</a> - тип, который нужен, чтобы объявить переменную <code>std::nothrow</code></li>
</ul>
<p>это версия оператора <code>new</code>, которая не бросает исключение</p>
<p>пример по ссылке выше</p>
<pre><code class="language-cpp">try {
    while (true) {
        new int[100000000ul];   // throwing overload
    }
} catch (const std::bad_alloc&amp; e) {
    std::cout &lt;&lt; e.what() &lt;&lt; '\n';
}

while (true) {
    int* p = new(std::nothrow) int[100000000ul]; // non-throwing overload
    if (p == nullptr) {
        std::cout &lt;&lt; &quot;Allocation returned nullptr\n&quot;;
        break;
    }
}
</code></pre>
<ul>
<li>можно написать <code>new</code> с произвольным набором параметров</li>
</ul>
<pre><code class="language-cpp">void* operator new(size_t n, int a, double b) {
    std::cout &lt;&lt; n &lt;&lt; &quot; bytes allocated with custom new &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;
    return malloc(n);
}

int main() {
    int* p = new(1, 3.14) int(5);
    delete p; // UB
}
</code></pre>
<p>если вызвали <code>new</code> с кастомными параметрами, то ему нужно симметрично вызывать <code>delete</code> с кастомными параметрами. но только для <code>delete</code> это будет именно функция <code>operator delete</code> и деструктор нужно будет вызывать руками. потому что нет синтаксиса по вызову оператора <code>delete</code> с кастомными параметрами</p>
<pre><code class="language-cpp">void* operator new(size_t n, int a, double b) {
    std::cout &lt;&lt; n &lt;&lt; &quot; bytes allocated with custom new &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;
    return malloc(n);
}

void operator delete(void* ptr, int a, double b) {
    std::cout &lt;&lt; &quot;custom delete called &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;
    free(ptr);
}

int main() {
    int* p = new(1, 3.14) int(5); // 4 bytes allocated with custom new 1 3.14
    operator delete(p, 1, 5.25); // custom delete called 1 5.25
}
</code></pre>
<p>следовательно, для нетривиального типа нужно было бы вручную вызывать деструктор</p>
<ul>
<li>сценарий, когда <code>delete</code> с кастомными параметрами вызывается за нас</li>
</ul>
<pre><code class="language-cpp">struct S {
    S() { throw 1; }
};
int main() {
    try {
        S* p = new(1, 3.14) S();
    } catch (...) {
        std::cout &lt;&lt; &quot;caught\n&quot;;
    }
}
</code></pre>
<p>в таком случае гарантируется, что за нас будет вызван оператор <code>delete</code> от таких же параметров на этом адресе, и только потом полетит исключение</p>
<ul>
<li>оператор <code>delete</code> и виртуальный деструктор</li>
</ul>
<pre><code class="language-cpp">struct Base {
    Base() { std::cout &lt;&lt; &quot;created Base\n&quot;; }
    ~Base() { std::cout &lt;&lt; &quot;destroyed Base\n&quot;; }
};

struct Derived : Base {
    int* p;
    Derived() {
        p = new int;
        std::cout &lt;&lt; &quot;created Derived\n&quot;;
    }
    ~Derived() {
        delete p;
        std::cout &lt;&lt; &quot;destroyed Derived\n&quot;;
    }
};

int main() {
    Base* b = new Derived;
    delete b;
}
</code></pre>
<p>здесь будет утечка памяти - уже разбирали</p>
<p>но даже так будет утечка</p>
<pre><code class="language-cpp">struct Base {
    Base() { std::cout &lt;&lt; &quot;created Base\n&quot;; }
    ~Base() { std::cout &lt;&lt; &quot;destroyed Base\n&quot;; }
};

struct Derived : Base {
    int x = 0;
    Derived() { std::cout &lt;&lt; &quot;created Derived\n&quot;; }
    ~Derived() { std::cout &lt;&lt; &quot;destroyed Derived\n&quot;; }
};

int main() {
    Base* b = new Derived;
    delete b;
}
</code></pre>
<p>откуда <code>delete</code> знает, какой деструктор ему вызвать и по какому указателю освободить память?</p>
<pre><code class="language-cpp">struct Base {
    Base() { std::cout &lt;&lt; &quot;created Base\n&quot;; }
    ~Base() { std::cout &lt;&lt; &quot;destroyed Base\n&quot;; }
};

struct Derived : Base {
    // int x = 0;
    Derived() { std::cout &lt;&lt; &quot;created Derived\n&quot;; }
    ~Derived() { std::cout &lt;&lt; &quot;destroyed Derived\n&quot;; }
};

int main() {
    Base* b = new Derived[5];
    delete[] b;
}
</code></pre>
<pre><code>created Base
created Derived
created Base
created Derived
created Base
created Derived
created Base
created Derived
created Base
created Derived
destroyed Base
destroyed Base
destroyed Base
destroyed Base
destroyed Base
</code></pre>
<p><code>delete[]</code> вызывает дестукторы, думая, что это массив из Base. а потом вызывает освобождение памяти, думая, что было столько Base, сколько он прочитал из сдвига. но на самом деле там были Derived</p>
<p>поэтому даже если нет выделения каких-то ресурсов, всё равно это будет неправильно работать - ещё одна причина делать виртуальный деструктор</p>
<p>такое будет работать только с одним объектом!!!</p>
<pre><code class="language-cpp">struct Base {
    Base() { std::cout &lt;&lt; &quot;created Base\n&quot;; }
    virtual ~Base() { std::cout &lt;&lt; &quot;destroyed Base\n&quot;; }
};

struct Derived : Base {
    int x = 0;
    Derived() { std::cout &lt;&lt; &quot;created Derived\n&quot;; }
    ~Derived() { std::cout &lt;&lt; &quot;destroyed Derived\n&quot;; }
};

int main() {
    Base* b = new Derived;
    delete b; // OK
}
</code></pre>
<p>но с <code>delete[]</code> всё равно будет утечка</p>
<pre><code class="language-cpp">struct Base {
    Base() { std::cout &lt;&lt; &quot;created Base\n&quot;; }
    virtual ~Base() { std::cout &lt;&lt; &quot;destroyed Base\n&quot;; }
};

struct Derived : Base {
    int x = 0;
    Derived() { std::cout &lt;&lt; &quot;created Derived\n&quot;; }
    ~Derived() { std::cout &lt;&lt; &quot;destroyed Derived\n&quot;; }
};

int main() {
    Base* b = new Derived[5];
    delete[] b;
}
</code></pre>
<pre><code>created Base
created Derived
created Base
created Derived
created Base
created Derived
created Base
created Derived
created Base
created Derived
destroyed Base
destroyed Base
destroyed Base
destroyed Base
destroyed Base
</code></pre>
<ul>
<li>оператор <code>new</code> как член класса</li>
</ul>
<pre><code class="language-cpp">struct S {
    void* operator new(size_t n) {
        std::cout &lt;&lt; &quot;operator new for S\n&quot;;
        return malloc(n);
    }

    void operator delete(void* ptr) {
        std::cout &lt;&lt; &quot;operator delete for S\n&quot;;
        free(ptr);
    }
};


int main() {
    S* p = new S;
    delete p;
}
</code></pre>
<pre><code>operator new for S
operator delete for S
</code></pre>
<p>можно так же для <code>new[]</code> и <code>delete[]</code></p>
<p>для этих методов <code>static</code> считается написанным по умолчанию</p>
<h2><a class="header" href="#Правильная-реализация-operator-new-из-стандартной-библиотеки" id="Правильная-реализация-operator-new-из-стандартной-библиотеки">Правильная реализация <code>operator new</code> из стандартной библиотеки</a></h2>
<p><a href="https://github.com/llvm/llvm-project/blob/18650480cb2ea46c9e8236c83593216af80fa25c/libcxx/src/new.cpp#L46C44-L46C52">код new</a> из libc - реализации стандартной библиотеки llvm</p>
<pre><code class="language-cpp">static void* operator_new_impl(std::size_t size) {
  if (size == 0)
    size = 1;
  void* p;
  while ((p = std::malloc(size)) == nullptr) {
    // If malloc fails and there is a new_handler,
    // call it to try free up memory.
    std::new_handler nh = std::get_new_handler();
    if (nh)
      nh();
    else
      break;
  }
  return p;
}

_LIBCPP_OVERRIDABLE_FUNCTION(_Znwm, void*, operator new, (std::size_t size)) _THROW_BAD_ALLOC {
  void* p = operator_new_impl(size);
  if (p == nullptr)
    __throw_bad_alloc_shim();
  return p;
}
</code></pre>
<p><code>new</code> всегда выделяет один байт. в си, а отличии от c++, не было требования, что все объекты имеют разные адреса</p>
<p><a href="https://en.cppreference.com/w/cpp/memory/new/new_handler">std::new_handler</a> - функция, которая должна попытаться что-то сделать в случае неудачного выделения памяти, прежде чем будет брошен bad_alloc (по умочанию ничего)</p>
<p>мы можем вызвать <a href="https://en.cppreference.com/w/cpp/memory/new/set_new_handler">std::set_new_handler</a> и передать туда адрес какой-то функции. она вызовется перед тем, как будет bad_alloc</p>
<p><code>_LIBCPP_WEAK</code> - макрос компилятора, который разрешает переопределять</p>
<h2><a class="header" href="#Запрет-создания-объектов-на-стекекуче" id="Запрет-создания-объектов-на-стекекуче">Запрет создания объектов на стеке/куче</a></h2>
<ul>
<li>
<p>как запретить создавать объекты какого-то типа T на куче (только на стеке)? можно пометить оператор <code>new</code> как <code>= delete</code></p>
</li>
<li>
<p>как запретить создавать объекты какого-то типа T на стеке (только на куче)? можно сделать деструктор приватным. создание объекта на стеке подразумевает автоматически возможность вызова деструктора</p>
</li>
</ul>
<p>но как создать объект на куче? - мы не сможем вызвать <code>delete</code></p>
<p>в C++20 добавили специальный оператор <code>delete</code> (destroying deallocation functions) - <a href="https://en.cppreference.com/w/cpp/memory/new/operator_delete">cppreference</a></p>
<p>это метод класса. в него нужно передать <a href="https://en.cppreference.com/w/cpp/memory/new/destroying_delete">std::destroying_delete</a>, тогда деструктор автоматически не вызывается. нам нужно вызывать его руками</p>
<h2><a class="header" href="#Выравнивания" id="Выравнивания">Выравнивания</a></h2>
<p>рассмортрим пример</p>
<pre><code class="language-cpp">int main() {
    int* a = new int[10];
    char* ac = reinterpret_cast&lt;char*&gt;(a);
    ++ac;
    int* b = reinterpret_cast&lt;int*&gt;(ac);

    *b = 1;
    int x = *b;
    std::cout &lt;&lt; x &lt;&lt; &quot;\n&quot;;

    delete[] a;
}
</code></pre>
<p>указатель на int, не кратный 4</p>
<p><code>-fsanitize=undefined</code>:</p>
<pre><code>probe.cpp:12:8: runtime error: store to misaligned address 0x58b345a832b1 for type 'int', which requires 4 byte alignment
0x58b345a832b1: note: pointer points here
 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00
              ^ 
probe.cpp:13:9: runtime error: load of misaligned address 0x58b345a832b1 for type 'int', which requires 4 byte alignment
0x58b345a832b1: note: pointer points here
 00 00 00  00 01 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00
              ^ 
1
</code></pre>
<p>по стандарту это UB. не все процессоры умеют читать по адресам, не кратнвым машинному слову</p>
<p>если мы пишем свой стековый аллокатор, надо следить за этим. если из нашего аллокатора сделали аллокатор на другой тип, надо чтобы этот тип лёг на адрес,   кратный нужному</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/memory/align">std::align</a> (C++11) - передаём указатель на буффер и его размер. оно сдвигает указатель, так чтобы он был выравнен, и уменьшает размер</li>
</ul>
<p>как узнать alignment?</p>
<ul>
<li>
<p>оператор <a href="https://en.cppreference.com/w/cpp/language/alignof">alignof</a> (C++11) - в compile time возвращает кратность выравнивания</p>
</li>
<li>
<p>как создать буффер, который будет изначально выравнен с каким-то сдвигом? - спецификатор <a href="https://en.cppreference.com/w/cpp/language/alignas">alignas</a> (C++11)</p>
</li>
</ul>
<p><code>alignas(число)</code> - перед объявлением перменной или типа</p>
<ul>
<li><a href="https://en.cppreference.com/w/c/memory/aligned_alloc">std::aligned_alloc</a> (C++17) - <code>malloc</code> с конкретным выравниванием</li>
</ul>
<p><code>malloc</code> (как и <code>new</code>) по умолчанию возвращает адрес по максимально возможному выравниванию для стандартных типов</p>
<p><a href="https://en.cppreference.com/w/cpp/types/max_align_t">std::max_align_t</a> - фейковый тип, который нужен чтобы узначать его выравнивание. его выравнивание максимально возможное из стандартных типов</p>
<h2><a class="header" href="#a-hrefhttpsencppreferencecomwcpplanguagebit_fieldБитовые-поля-bit-fieldsa" id="a-hrefhttpsencppreferencecomwcpplanguagebit_fieldБитовые-поля-bit-fieldsa"><a href="https://en.cppreference.com/w/cpp/language/bit_field">Битовые поля (Bit-fields)</a></a></h2>
<p>можно попросить, чтобы поле стуктуры занимало определенное количество бит, а не байт</p>
<p>пример из cppreference</p>
<pre><code class="language-cpp">struct S {
    // three-bit unsigned field, allowed values are 0...7
    unsigned int b : 3;
};
 
int main() {
    S s = {6};
    ++s.b; // store the value 7 in the bit-field
    std::cout &lt;&lt; s.b &lt;&lt; '\n'; // 7

    ++s.b; // the value 8 does not fit in this bit-field
    std::cout &lt;&lt; s.b &lt;&lt; '\n'; // formally implementation-defined, typically 0
}
</code></pre>
<h1><a class="header" href="#Лекция-38" id="Лекция-38">Лекция 38</a></h1>
<h2><a class="header" href="#scoped-allocators" id="scoped-allocators">Scoped allocators</a></h2>
<p>допустим, что мы хотим создавать контейнер из контейнеров, как передать нужный аллокатор внутрь?</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
using MyAlloc = std::allocator&lt;T&gt;;

int main() {
    using MyString = std::basic_string&lt;char, std::char_traits&lt;char&gt;, MyAlloc&lt;char&gt;&gt;;
    MyAlloc&lt;MyString&gt; alloc;

    std::vector&lt;MyString, MyAlloc&lt;MyString&gt;&gt; v(alloc);
    v.push_back(&quot;abc&quot;);
    v.push_back(&quot;cde&quot;);
}
</code></pre>
<p>что здесь не так?</p>
<p>пусть MyAlloc это PoolAllocator, но тогда все строки будут иметь разные экзмепляры этого аллокатора (будет столько пулов, сколько строк в векторе)</p>
<p>но хотим использовать один (равный для всех) аллокатор. решение:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor">std::scoped_allocator_adaptor</a> (C++11)</li>
</ul>
<pre><code class="language-cpp">std::vector&lt;MyString, std::scoped_allocator_adaptor&lt;MyAlloc&lt;MyString&gt;&gt;&gt; v(alloc);
</code></pre>
<p>в <code>scoped_allocator_adaptor</code> можно передать несколько аллокаторов - на каждый уровень вложенности контейнеров</p>
<p>как должен работать <code>construct</code>? он должен создать объект T и передать экземпляр аллокатора в то, что он создаёт</p>
<p>очень примерная реализация</p>
<pre><code class="language-cpp">template &lt;typename Alloc&gt;
struct scoped_allocator_adaptor {
    Alloc alloc_;
    
    template&lt;typename T, typename... Args&gt;
    void construct(T* ptr, const Args&amp;... args) {
        using InnerAlloc = typename T::allocator_type;
        alloc_.construct(ptr, args..., InnerAlloc(alloc_)); // передаем копию нашего аллокатора, но с правильным типом
    }
};
</code></pre>
<p>вызывали construct строки с аргументами конструктора и дополнительным последним аргументом - аллокатор</p>
<p>но нужно проверить, умеет ли объект T в принципе принимать аллокаторы?</p>
<p><a href="https://en.cppreference.com/w/cpp/memory/uses_allocator">std::uses_allocator</a> - проверяет, есть ли у типа T using allocator_type, который создаётся из нашего аллокатора</p>
<pre><code class="language-cpp">template &lt;typename Alloc&gt;
struct scoped_allocator_adaptor {
    Alloc alloc_;

    template&lt;typename T, typename... Args&gt;
    void construct(T* ptr, const Args&amp;... args) {
        if constexpr (std::uses_allocator_v&lt;T, Alloc&gt;) {
            using InnerAlloc = typename T::allocator_type;
            alloc_.construct(ptr, args..., InnerAlloc(alloc_));
        } else {
            alloc_.construct(ptr, args...);
        }
    }
};
</code></pre>
<p>это всё ещё не совсем правда, не будем углубляться в точную реализацию</p>
<h2><a class="header" href="#a-hrefhttpsencppreferencecomwcpplanguageattributesАтрибутыa-c11" id="a-hrefhttpsencppreferencecomwcpplanguageattributesАтрибутыa-c11"><a href="https://en.cppreference.com/w/cpp/language/attributes">Атрибуты</a> (C++11)</a></h2>
<p>можно помечать функции и аргменты функций атрибутами</p>
<p>они пишутся в двойных квадратных скобках <code>[[...]]</code></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/attributes/no_unique_address">no_unique_address</a> - можно этому объекту не заводить отдельный адрес</li>
<li><a href="https://en.cppreference.com/w/cpp/language/attributes/nodiscard">nodiscard</a> - выдаёт warning, если результат функции не используется</li>
<li><a href="https://en.cppreference.com/w/cpp/language/attributes/deprecated">deprecated</a> - что-то устарело</li>
<li><a href="https://en.cppreference.com/w/cpp/language/attributes/maybe_unused">maybe_unused</a> - этот аргумент может не использоваться в теле функции</li>
<li><a href="https://en.cppreference.com/w/cpp/language/attributes/likely">likely/unlikely</a> - подсказки о ветвлении, чтобы лучше оптимизировать код</li>
<li><a href="https://en.cppreference.com/w/cpp/language/attributes/assume">assume</a> - предположение о каком-то условии, чтобы исходя из этого условия лучше оптимизировать код</li>
</ul>
<h2><a class="header" href="#a-hreflecturesmovetheoryhtmlmove-семантикаa-С11" id="a-hreflecturesmovetheoryhtmlmove-семантикаa-С11"><a href="lectures/../move/theory.html">Move-семантика</a> (С++11)</a></h2>
<p>с нашими текущими знаниями очевидно, что многие вещи работают не оптимально</p>
<ul>
<li>рассмотрим пример</li>
</ul>
<pre><code class="language-cpp">std::vector&lt;std::string&gt; v;
v.push_back(&quot;abc&quot;);
</code></pre>
<p>где <code>push_back</code> выглядит вот так</p>
<pre><code class="language-cpp">void push_back(const T&amp; value) {
    // ...
    new(ptr) T(value); // явно такого нет, но сводится к этому
    // ...
}
</code></pre>
<p>что происходит со строкой?</p>
<ol>
<li>создаётся временная строка из <code>const char*</code></li>
<li>к ней привязывается константкая ссылка, как к временному объекту</li>
<li>вызывается конструктор с помощью <code>placement new</code></li>
<li>временная строка уничтожается</li>
</ol>
<p>итого: было создано 2 строки</p>
<p>как нам научиться класть объекты так, чтобы не копировать их второй раз?</p>
<p>даже если напишем так, это ничему не поможет</p>
<pre><code class="language-cpp">v.push_back(std::string(&quot;cde&quot;));
</code></pre>
<ul>
<li><code>emplace_back</code> - метод, который принимает не объект T, а аргументы, из которых создаёт T на месте</li>
</ul>
<pre><code class="language-cpp">template &lt;typename... Args&gt;
void emplace_back(const Args&amp;... args) {
    // ...
    new(ptr) T(args...);
    // ...
}
</code></pre>
<p>здесь</p>
<ol>
<li>принимается ссылка на <code>const char*</code></li>
<li>вызывается конструктор с помощью <code>placement new</code></li>
</ol>
<p>итог: создана только 1 строчка</p>
<p>но глобально это проблему не решает. мы просто спустили проблему на уровень глубже. пример - <code>std::vector&lt;std::vector&lt;std::string&gt;&gt;</code>. промежуточный вектор создан не будет, но под каждую строку будет создан промежуточный объект</p>
<ul>
<li>проблема не только с контейнерами, а с любым сохранением данных в какой-то класс</li>
</ul>
<pre><code class="language-cpp">struct S {
    std::string data;
    S(const std::string&amp; str) : data(str) {}
};
</code></pre>
<p>как бы мы не приняли строку (по значению, ссылке, константной ссылке), нам нужно будет её скопировать</p>
<ul>
<li>ещё одна проблема - исключения</li>
</ul>
<pre><code class="language-cpp">std::string s(&quot;abc&quot;);
throw s;
</code></pre>
<p>чтобы бросить объект, надо сначала его создать, а только потом скопировать в динамическую память</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/move_constructor">move конструктор</a><br />
идея: хотим забирать данные, а не копировать</li>
</ul>
<p>мы берём строку, её поля зануляем, а себе забирем то, что у неё лежало</p>
<pre><code class="language-cpp">class string {
public:
    string(string&amp;&amp; other) // некий новый тип ссылок
        : arr(other.arr), sz(other.sz), cap(other.cap)
    {
        other.arr = nullptr;
        other.sz = other.cap = 0;
    }

private:
    char* arr;
    size_t sz;
    size_t cap;
};
</code></pre>
<p>мы пока не знаем, что это за тип - <code>string&amp;&amp;</code>. объясним это позже</p>
<p>зачем мы делаем <code>other.sz = other.cap = 0</code>? мы хотим, чтобы объект остался в консистентном состоянии (чтобы мы могли им дальше пользоваться)</p>
<p>можно сделать <code>= default</code>. тогда просто поэлеметно будут вызваны move конструкторы полей. а если поля обычные типы, то будет обычное копирование</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/move_assignment">move оператор присваивания</a></li>
</ul>
<pre><code class="language-cpp">string&amp; operator=(string&amp;&amp; other) {
    if (this == &amp;other){
        return *this;
    }
    delete[] arr;

    arr = other.arr; other.arr = nullptr;
    sz  = other.sz;  other.sz  = 0;
    cap = other.cap; other.cap = 0;
    return *this;
}
</code></pre>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/rule_of_three">rule of five</a></li>
</ul>
<p>Если у нас в классе есть хотя бы один нетривиальный:</p>
<ol>
<li><strong>copy конструктор</strong></li>
<li><strong>copy assignment оператор</strong></li>
<li><strong>деструктор</strong></li>
<li><strong>move конструктор</strong></li>
<li><strong>move assignment оператор</strong></li>
</ol>
<p>то надо реализовать их всех</p>
<ul>
<li>move для базовых типов = копирование !!!</li>
</ul>
<p>поэтому дефолтный move конструктор не подходит для строки, вектора и любых типов, у которых нетривиальное копирование (скопируется указатель)</p>
<p>можно вообще не писать move конструктор и move оператор присваивания, тогда в случае попытки их вызова будут вызываться их копирующие аналоги</p>
<p>это и есть обратная совместимость с C++03: если не упоминаем move конструктор и move оператор присваивания, то всё работает по старинке (как будто мы копируем). именно поэтому весь наш прошлый код работал ожидаемо</p>
<h1><a class="header" href="#Лекция-39" id="Лекция-39">Лекция 39</a></h1>
<ul>
<li>тип, который можно мувать, но нельзя копировать</li>
</ul>
<p>можно написать для типа move операции, но для копирования пометить <code>= delete</code></p>
<p>пример - <code>std::unique_ptr</code>. понятно, что по смыслу его нельзя скопировать. но можно мувнуть, забрав владение</p>
<h2><a class="header" href="#mistic-function-a-hrefhttpsencppreferencecomwcpputilitymovestdmovea" id="mistic-function-a-hrefhttpsencppreferencecomwcpputilitymovestdmovea">Mistic function <a href="https://en.cppreference.com/w/cpp/utility/move">std::move</a></a></h2>
<p>как компилятор понимает, когда вызывать move операции?</p>
<p>короткий ответ: если компилятор видит, что мы вызываемся от rvalue, то он автоматически вызывает move операцию (если может), а от lvalue вызывает копирующую операцию</p>
<p><code>std::move</code> - функция, которая заставляет вызвать move операцию, несмотря на то, что переменная была lvalue (пока это не точное и наивное определение)</p>
<p>хотим написать что-то такое</p>
<pre><code class="language-cpp">struct S {
    std::string data;
    S(const std::string&amp; data) : data(std::move(data)) {}
};
</code></pre>
<p>но здесь это не сработает, здесь будет копирование из-за <code>const</code>, а мувающая версия принимает неконстантный тип</p>
<p>поэтому надо написать вот так</p>
<pre><code class="language-cpp">struct S {
    std::string data;
    S(const std::string&amp; data) : data(data) {}
    S(std::string&amp;&amp; data) : data(std::move(data)) {}
};
</code></pre>
<p>для lvalue - будет работать как раньше<br />
для rvalue - попадем в move конструктор</p>
<pre><code class="language-cpp">struct S {
    std::string data;
    S(const std::string&amp; data) : data(data) {
        std::cout &lt;&lt; &quot;1\n&quot;;
    }
    S(std::string&amp;&amp; data) : data(std::move(data)) {
        std::cout &lt;&lt; &quot;2\n&quot;;
    }
};

int main() {
    std::string str = &quot;abc&quot;;
    S s1(str); // 1
    S s2(&quot;cde&quot;); // 2
}
</code></pre>
<p>причем если мы не напишем <code>std::move</code>, то всё равно будет копирование. data это не временный объект. <code>std::string&amp;&amp;</code> просто позволяет вызваться от временного объекта, но сам объект data уже не временный !!!</p>
<p>роль move в том, чтобы перенаправить перегрузку функции по другому пути (move операции)</p>
<ul>
<li>как теперь решить проблему с <code>push_back</code>?</li>
</ul>
<pre><code class="language-cpp">void push_back(const T&amp; value) {
    // ...
    new(ptr) T(value);
    // ...
}

void push_back(T&amp;&amp; value) { // для временного объекта
    // ...
    new(ptr) T(std::move(value));
    // ...
}
</code></pre>
<ul>
<li>как решить проблему с исключениями?</li>
</ul>
<p>она решена сама собой</p>
<pre><code class="language-cpp">std::string s(&quot;abc&quot;);
throw s;
</code></pre>
<p>с C++11 по стандарту вызывается move конструктор, а не copy конструктор (по возможности)</p>
<ul>
<li>реализцая <code>std::swap</code> через <code>std::move</code></li>
</ul>
<p>наша старая плохая реализация</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void swap(T&amp; x, T&amp; y) {
    T tmp = x;
    x = y;
    y = tmp;
}
</code></pre>
<p>трижды линейное время (в случае долгих копирований)</p>
<p>хорошая реализация</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void swap(T&amp; x, T&amp; y) {
    T tmp = std::move(x);
    x = std::move(y);
    y = std::move(tmp);
}
</code></pre>
<p>константное время, если тип поддерживает move операции</p>
<ul>
<li>наивная реализация <code>std::move</code></li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; move(T&amp; x) {
    return static_cast&lt;T&amp;&amp;&gt;(x);
}
</code></pre>
<p>это неправильная реализация. такое работает в 90% случаев и покрывает все те случаи, которые были выше</p>
<p>функция <code>move</code> ничего никуда не мувает. это просто каст к rvalue. для процессора в рантайме она не означает никаких инструкций, она имеет смысл только на этапе компиляции</p>
<p>заметим, что такое не сработает</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; move(T&amp; x) {
    return x;
}
</code></pre>
<p>нет неявного каста из <code>T&amp;</code> в <code>T&amp;&amp;</code> (наоборот есть, обсудим позже)</p>
<h2><a class="header" href="#Формальное-определение-rvalue-и-lvalue" id="Формальное-определение-rvalue-и-lvalue">Формальное определение rvalue и lvalue</a></h2>
<p>lvalue и rvalue are categories of <a href="https://en.cppreference.com/w/cpp/language/expressions">expressions</a>, not types !!!</p>
<p>некорректен вопрос: какого value этот тип? типы не обладают никаким видом value сами по себе. только выражения обдалают видом value</p>
<p>цитата из cppreference: <code>Each C++ expression is characterized by two independent properties: A type and a value category.</code></p>
<p>если говорить философски:</p>
<ul>
<li>lvalue - то, что лежит в памяти</li>
<li>rvalue - то, что необязательно лежит в памяти</li>
</ul>
<p>Формальное определение:</p>
<table>
<tr>
<th> lvalue </th>
<th> rvalue </th>
</tr>
<tr>
<td>
<ul>
<li>id; (любая переменная сама по себе, это lvalue, неважно какой у нее тип).  идентификатор - частный случай expression</li>
<li>cтроковые литералы: <code>&quot;abc&quot;</code></li>
<li><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code></li>
<li><code>++expr</code>, <code>--expr</code></li>
<li><code>*ptr</code>, <code>a[i]</code></li>
<li><code>a, b</code> (comma) if rhs is lvalue</li>
<li><code>a ? b : c</code> (conditional) if both operands are lvalue</li>
<li><code>a(...)</code> (function call) is lvalue, if return type is <code>T&amp;</code></li>
<li>cast-expression is lvalue, if return type is <code>T&amp;</code></li>
</ul>
</td>
<td>
<ul>
<li>литералы: <code>5</code>, <code>'a'</code>, <code>2.0f</code>, <code>true</code> (кроме случаев, когда это строковый литерал)</li>
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code> (над фундаментальными типами)</li>
<li><code>expr++</code>, <code>expr--</code> (над фундаментальными типами)</li>
<li><code>&amp;a</code></li>
<li><code>a, b</code> (comma) if rhs is rvalue</li>
<li><code>a ? b : c</code> (conditional) at least one operand is rvalue</li>
<li><code>a(...)</code> (function call) is rvalue, if return type is <code>T</code> or <code>T&amp;&amp;</code></li>
<li>cast-expression is rvalue, if return type is <code>T</code> or <code>T&amp;&amp;</code></li>
<li><code>new</code></li>
</ul>
</td>
</tr>
</table>
<h2><a class="header" href="#rvalue-ссылки" id="rvalue-ссылки">Rvalue-ссылки</a></h2>
<p>rvalue ссылка - тип такого вида: <code>T&amp;&amp;</code>, где T - некоторый фиксированный тип</p>
<p>Свойства:</p>
<ol>
<li>rvalue ссылка - такая ссылка, которая будучи возвращённой из функции считается rvalue</li>
<li>проинициализировать её можно только rvalue выражением</li>
</ol>
<ul>
<li>пример 1</li>
</ul>
<pre><code class="language-cpp">int x = 5;
int&amp;&amp; y = x; // CE
</code></pre>
<p>x - не rvalue</p>
<ul>
<li>пример 2</li>
</ul>
<pre><code class="language-cpp">int&amp;&amp; y = 6; // OK
</code></pre>
<p>продление жизни (lifetime prolongation)</p>
<ul>
<li>пример 3</li>
</ul>
<pre><code class="language-cpp">int&amp;&amp; y = 6;
y = 7; // OK
</code></pre>
<p>создали временный объект типа int от 6, и изменили его на 7 </p>
<ul>
<li>пример 4</li>
</ul>
<pre><code class="language-cpp">int&amp;&amp; y = 6;
int&amp;&amp; z = y; // CE
</code></pre>
<p>имя переменной - это всегда lvalue, неважно какой у нее тип. чтобы это работало и нужен <code>std::move</code></p>
<ul>
<li>пример 5</li>
</ul>
<pre><code class="language-cpp">int&amp;&amp; y = 6;
int&amp;&amp; z = std::move(y); // OK
</code></pre>
<ul>
<li>пример 6</li>
</ul>
<pre><code class="language-cpp">int x = 5;
int&amp;&amp; t = static_cast&lt;int&amp;&amp;&gt;(x); // OK
</code></pre>
<p>аналогично, только руками делаем каст</p>
<ul>
<li>пример 7</li>
</ul>
<pre><code class="language-cpp">int x = 5;
int&amp;&amp; t = static_cast&lt;int&amp;&amp;&gt;(x);
t = 1; // x = 1
</code></pre>
<p>t это такая же ссылка, как и раньше (другое названия для x)</p>
<h1><a class="header" href="#Лекция-40" id="Лекция-40">Лекция 40</a></h1>
<ul>
<li>как можно интуитивно понимать <code>std::move</code></li>
</ul>
<p><img src="lectures/img/43.png" alt="alt text" />
(тут на картинки не симметричные, но смысла не меняет)</p>
<p>type - тип, над которым определено больше операций, чем над const type. Если мы хотим const type принять по type ссылке (разрешить над ним операции, которые по умолчанию над ним запрещены), мы должны явно писать <code>const_cast</code>, но обратно работает неявно</p>
<p>аналогично, Derived - тип, над которым определено больше операций, чем над Base. если мы хотим Base принять по Derived ссылке (расширить круг операций), мы должны явно писать <code>static_cast</code>, но обратно тоже работает неявно</p>
<p>то есть сужать множество операций можно неявно, а расширять надо явно через каст</p>
<p>аналогично для видов value</p>
<p><code>std::move</code> это в каком-то виде каст, но не между типами, а между value. над lvalue определены какие-то операции, а над rvalue определено больше операций. потому что над rvalue определена операция - забрать его данные и опустошить его, а самому себе присвоить то, что ему принадлежало</p>
<p>поэтому можно сказать, что <code>std::move</code> это и есть каст, расширяющий множество операций</p>
<p><img src="lectures/img/44.png" alt="alt text" /></p>
<ul>
<li>вспомним свойста rvalue ссылок</li>
</ul>
<pre><code class="language-cpp">int x = 5;
int&amp;&amp; y = std::move(x);
int&amp;&amp; z = std::move(y);
int t = 6;
z = t;
std::cout &lt;&lt; x &lt;&lt; y &lt;&lt; z; // 666
</code></pre>
<p>по сути, имеем 3 имени для одной переменной x</p>
<p>rvalue ссылки так же умеют продлевать жизнь объектам</p>
<pre><code class="language-cpp">int&amp;&amp; r = 1;
</code></pre>
<p>создастся объект, к которому будет привязано имя r, также как</p>
<pre><code class="language-cpp">const int&amp; r = 1;
</code></pre>
<p>но в старом случае его нельзя было менять, а сейчас можно</p>
<p><code>T&amp;&amp;</code> -&gt; <code>T&amp;</code> кастится неявно</p>
<pre><code class="language-cpp">int x = 5;
int&amp;&amp; y = std::move(x); // OK
int&amp; z = y; // OK
z = 6;
std::cout &lt;&lt; x &lt;&lt; y &lt;&lt; z; // 666
</code></pre>
<h2><a class="header" href="#Взаимодействие-rvalue-ссылок-и-const" id="Взаимодействие-rvalue-ссылок-и-const">Взаимодействие rvalue-ссылок и const</a></h2>
<ul>
<li>правила константности действуют независимо от правил вида value</li>
</ul>
<p>навешивать const можно, снимать только через <code>const_cast</code></p>
<pre><code class="language-cpp">int x = 5;
const int&amp;&amp; y = std::move(x); // OK
int&amp;&amp; z1 = std::move(y); // CE
int&amp;&amp; z2 = std::move(const_cast&lt;int&amp;&gt;(y)); // OK
int&amp;&amp; z3 = const_cast&lt;int&amp;&amp;&gt;(std::move(y)); // OK
z3 = 6;
std::cout &lt;&lt; x &lt;&lt; z2 &lt;&lt; z3; // 666
</code></pre>
<p><code>const_cast</code> для z2 нужен именно, чтобы убрать константность c <code>const int&amp;&amp;</code>, а дальше каст <code>int&amp;&amp;</code> -&gt; <code>int&amp;</code> сделается неявно</p>
<p>на самом деле <code>const_cast</code> можно делать даже без <code>std::move</code></p>
<pre><code class="language-cpp">int x = 5;
const int&amp;&amp; y = std::move(x); // OK
int&amp;&amp; z = const_cast&lt;int&amp;&amp;&gt;(y); // OK
z = 6;
std::cout &lt;&lt; x &lt;&lt; z; // 66
</code></pre>
<ul>
<li>если бы в нашей реализации move с прошлой лекции, мы приняли <code>const T&amp;</code></li>
</ul>
<p>такое не работает</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; move(const T&amp; x){
    return static_cast&lt;T&amp;&amp;&gt;(x); // CE
}
</code></pre>
<p>нельзя с помощью <code>static_cast</code> скастовать от константного T к неконстантному</p>
<ul>
<li>рассмотрим такую функцию</li>
</ul>
<pre><code class="language-cpp">template &lt;typename U&gt;
void f(const U&amp; x){
    g(std::move(x));
}
</code></pre>
<p>в move попадёт шаблонный тип <code>T</code> = <code>const U</code> из нашей функции f, поэтому из move мы вернем <code>const U&amp;&amp;</code></p>
<p>если функция g определена двумя способами (пусть для строчек)</p>
<pre><code class="language-cpp">void g(const std::string&amp; x) {/**/}
void g(std::string&amp;&amp; x) {/**/}
</code></pre>
<p>то мы попадём в первую версию <code>const std::string&amp;</code>. мы не можем отдать константное rvalue, туда где ожидается неконстантное rvalue</p>
<p><code>const U&amp;&amp;</code> - &gt; <code>const U&amp;</code> - OK<br />
<code>const U&amp;&amp;</code> - &gt; <code>U&amp;&amp;</code> - CE</p>
<p>поэтому, если мы мувнем константный тип, ничего плохого не случится!</p>
<p>мы всё равно попадём в копирующую версию (если представить что g это не функция, а конструктор). константность независимо от вида value защищает от изменений</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; move(T&amp; x) {
    return static_cast&lt;T&amp;&amp;&gt;(x);
}

void g(std::string&amp;&amp; x) {
    std::cout &lt;&lt; &quot;std::string&amp;&amp;\n&quot;;
    x = &quot;cde&quot;; // пытаемся испортить строку
}
void g(const std::string&amp;) {
    std::cout &lt;&lt; &quot;const std::string&amp;\n&quot;;
}

template &lt;typename U&gt;
void f(const U&amp; x){
    g(move(x));
}

int main() {
    std::string s = &quot;abc&quot;;
    f(s);
    std::cout &lt;&lt; s &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<pre><code>const std::string&amp;
abc
</code></pre>
<h2><a class="header" href="#Закрепим-знания-про-rvalue-ссылки" id="Закрепим-знания-про-rvalue-ссылки">Закрепим знания про rvalue-ссылки</a></h2>
<ul>
<li><code>T&amp;&amp;</code> - это такой тип, который во всем аналогичен <code>T&amp;</code>, кроме двух основных пунктов: инициализировать его можно только через rvalue, и если вернуть такой тип из функции, то это выражение будет считаться rvalue</li>
</ul>
<p>обычная ссылка, просто инициализировали через rvalue</p>
<pre><code class="language-cpp">std::string x = &quot;abc&quot;;
std::string&amp;&amp; y = std::move(x);
std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;; // abc abc
</code></pre>
<p>но вот так</p>
<pre><code class="language-cpp">std::string x = &quot;abc&quot;;
std::string y = std::move(x);
std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; y.empty() &lt;&lt; &quot;\n&quot;; // abc 0
</code></pre>
<p>вызвался мув конструктор от строчки x, мы забрали её содержимое, поэтому она теперь пустая</p>
<h2><a class="header" href="#reference-qualifiers" id="reference-qualifiers">Reference qualifiers</a></h2>
<pre><code class="language-cpp">struct S {
    std::string str;
    std::string getData() const {
        return str;
    }
};

int main() {
    S{&quot;abc&quot;}.getData();
}
</code></pre>
<p>здесь</p>
<ol>
<li>создастся строка str от &quot;abc&quot;</li>
<li>в getData() из str создастся еще одна строка и вернется наружу</li>
</ol>
<p>иногда хочется иначе работать с объектом, если <code>*this</code> это rvalue. хотим, чтобы при вызове метода у rvalue объекта, getData мувала бы строку, а не копировала её</p>
<p>у нас уже есть перегрузка между const и не const объектами. научимся ещё делать перегрузку между rvalue и lvalue объектами</p>
<ul>
<li>Reference qualifiers (C++11)</li>
</ul>
<pre><code class="language-cpp">std::string getData() &amp;&amp; {
    return std::move(str);
}
</code></pre>
<p>теперь этот метод доступен только для rvalue объектов</p>
<p>мы хотим достать строку из временного объекта, который сейчас умрёт. поэтому мы возвращаем строку по значению, она будет создана мув конструктором из str. str станет пустой, но нам это и не важно, ведь весь объект S сейчас умрёт</p>
<ul>
<li>симметрично можно сделать только для lvalue объектов</li>
</ul>
<pre><code class="language-cpp">std::string getData() &amp; {
    return str;
}
</code></pre>
<ul>
<li>но если написать вот так</li>
</ul>
<pre><code class="language-cpp">std::string getData() const &amp; {
    return std::move(str);
}
</code></pre>
<p>аналогично константным ссылкам в параметрах. сможем вызываться, как от lvalue, так и от rvalue</p>
<p>мы как будто приняли себя по константной ссылке</p>
<ul>
<li>перегрузка, когда мы себя приняли по константной ссылке и по rvalue ссылке</li>
</ul>
<pre><code class="language-cpp">struct S {
    std::string str;
    std::string getData() const &amp; {
        return str;
    }
    std::string getData() &amp;&amp; {
        return std::move(str);
    }
};
</code></pre>
<p>в 1 случае себя менять нельзя (как будто по константной ссылке), во 2 случае можем из себя достать данные (как будто по rvalue ссылке)</p>
<pre><code class="language-cpp">S s = S{&quot;abc&quot;};
std::cout &lt;&lt; s.getData() &lt;&lt; &quot;\n&quot;; // abc
std::cout &lt;&lt; std::move(s).getData() &lt;&lt; &quot;\n&quot;; // abc
std::cout &lt;&lt; s.getData() &lt;&lt; &quot;\n&quot;; // пустая строка
</code></pre>
<p>1 и 3 строка - вызываемся от lvalue. во 2 строке вытащили строку str из объекта s</p>
<pre><code class="language-cpp">const S s = S{&quot;abc&quot;};
std::cout &lt;&lt; s.getData() &lt;&lt; &quot;\n&quot;; // abc
std::cout &lt;&lt; std::move(s).getData() &lt;&lt; &quot;\n&quot;; // abc
std::cout &lt;&lt; s.getData() &lt;&lt; &quot;\n&quot;; // abc
</code></pre>
<p><code>std::move(s)</code> сделал каст <code>const std::string&amp;</code> -&gt; <code>const std::string&amp;&amp;</code>. как и обсуждали раньше, такое неявно скастится к <code>const std::string&amp;</code> и вызовется первая версия</p>
<ul>
<li>если напишем так</li>
</ul>
<pre><code class="language-cpp">struct S {
    std::string str;  
    std::string getData() &amp; {
        return str;
    }
    std::string getData() &amp;&amp; {
        return std::move(str);
    }
};
</code></pre>
<p>то 1 метод можно будет вызывать только от lvalue, но его нельзя будет вызывать от константых объектов</p>
<p>здесь будет аналогично</p>
<pre><code class="language-cpp">S s = S{&quot;abc&quot;};
std::cout &lt;&lt; s.getData() &lt;&lt; &quot;\n&quot;; // abc
std::cout &lt;&lt; std::move(s).getData() &lt;&lt; &quot;\n&quot;; // abc
std::cout &lt;&lt; s.getData() &lt;&lt; &quot;\n&quot;; // пустая строка
</code></pre>
<p>но вот здесь</p>
<pre><code class="language-cpp">const S s = S{&quot;abc&quot;};
std::cout &lt;&lt; s.getData() &lt;&lt; &quot;\n&quot;; // CE
std::cout &lt;&lt; std::move(s).getData() &lt;&lt; &quot;\n&quot;; // CE
</code></pre>
<p>но вот так всё ок - сбросили const, добавили &amp;</p>
<pre><code class="language-cpp">const S s = S{&quot;abc&quot;};
std::cout &lt;&lt; std::move(const_cast&lt;S&amp;&gt;(s)).getData() &lt;&lt; &quot;\n&quot;; // abc
</code></pre>
<ul>
<li>вывод: в операторе присваивания нужно писать &amp;, чтобы к rvalue ничего нельзя было присвоить</li>
</ul>
<h2><a class="header" href="#forwarding-references" id="forwarding-references">Forwarding references</a></h2>
<ul>
<li>вспомним проблему <code>push_back</code>. у нас было 2 метода</li>
</ul>
<pre><code class="language-cpp">void push_back(const T&amp;) {/**/}
void push_back(T&amp;&amp;) {/**/}
</code></pre>
<p>они отличаются только одной строчкой</p>
<pre><code class="language-cpp">new(ptr) T(value);
new(ptr) T(std::move(value));
</code></pre>
<p>но это обман. ведь на самом деле там написано <code>alloc.construct(...)</code>. как она выглядит? <a href="lectures/./code/lec36/allocator.cpp">ответ</a></p>
<pre><code class="language-cpp">template &lt;typename U, typename... Args&gt;
void construct(U* ptr, const Args&amp;... args) {
    new (ptr) U(args...);
}
</code></pre>
<p>мы принимаем аргументы по константной ссылке. то есть мы не можем так мувать аргументы</p>
<p>но принять по rvalue ссылке <code>Args&amp;&amp;... args</code> мы не можем, т.к. тогда это не будет работать для lvalue</p>
<ul>
<li>такая же проблема c <code>emplace_back</code></li>
</ul>
<pre><code class="language-cpp">template &lt;typename... Args&gt;
void emplace_back(const Args&amp;... args) {
    // ...
    new(ptr) T(args...);
    // ...
}
</code></pre>
<p>всё аналогично -  аргументы будут копироваться</p>
<ul>
<li>в обоих функциях у нас переменное число аргументов. некоторые из них могут быть lvalue, а некоторые rvalue. т.е. нужно сделать $2^n$ перегрузок</li>
</ul>
<p>мы научились копировать или мувать, пока это не передаётся дальше. но если нужно передать это в следующую функцию с сохранением вида value, мы не умеем такого</p>
<p>нам нужно уметь передавать аргументы дальше в функции с сохранением вида value - того, по которому мы их приняли на данный момент. если в <code>emplace_back</code> часть аргументов нам отдали как rvalue, а часть аргументов отдали как lvalue, мы должны и дальше в <code>construct</code> отдать соответствующие аргументы как rvalue, а другие как lvalue</p>
<ul>
<li>на самом деле сигнатура <code>emplace_back</code> всё таки выглядит так</li>
</ul>
<pre><code class="language-cpp">template &lt;typename... Args&gt;
void emplace_back(Args&amp;&amp;... args) {/**/}
</code></pre>
<p>как же это работает?</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/utility/forward">std::forward</a> решает эту проблему</li>
</ul>
<p>правильная передача аргументов с сохранением вида value в следующую функцию выглядит так</p>
<pre><code class="language-cpp">template &lt;typename U, typename... Args&gt;
void construct(U* ptr, Args&amp;&amp;... args) {
    new (ptr) U(std::forward&lt;Args&gt;(args)...);
}
</code></pre>
<p>мы принимаем их вот по такой ссылке, но передаем дальше с помощью <code>std::forward</code></p>
<p>функция <code>std::forward</code> в зависимости от того, приняли ли мы аргументы как lvalue или rvalue изначально, и дальше передает их как lvalue и rvalue соответственно</p>
<ul>
<li>но каким образом мы в <code>Args&amp;&amp;... args</code> принимаем хоть какое-то lvalue? ведь это противоречит определению rvalue-ссылки</li>
</ul>
<p><strong>нужно ввести костыль. если вот такая ссылка является шаблонным параметром функции, то это правило неверно</strong></p>
<h2><a class="header" href="#forwarding-universal-references" id="forwarding-universal-references">Forwarding (universal) references</a></h2>
<p>если такая ссылка <code>T&amp;&amp;</code> является типом аргумента функции, для которой тип T является шаблонным параметром, то не применяется правило, что её можно инициализировать только через rvalue</p>
<p>поэтому можно таким синтаксисом можно принимать как lvalue, так и rvalue</p>
<p>еще раз: если функция принимает тип вида <code>T&amp;&amp;</code> , где T - это шаблонный параметр данной функции, то такая ссылка работает по иным правилам, нежели обычная rvalue ссылка</p>
<ol>
<li>важно, чтобы тип был шаблонным параметром самой функции, а не вышележащего класса !!!</li>
</ol>
<pre><code class="language-cpp">void push_back(T&amp;&amp;) {/**/}
</code></pre>
<p>вот это не попадает под исключение из правил, это шаблонный параметр класса!</p>
<ol start="2">
<li>важно, чтобы тип был в точность равен типу шаблонного параметра + <code>&amp;&amp;</code></li>
</ol>
<pre><code class="language-cpp">template &lt;typename U, typename... Args&gt;
void construct(U* ptr, const Args&amp;&amp;... args) {/**/}
</code></pre>
<p>тоже не попадает под исключение из правил, навесили const!</p>
<ol start="3">
<li>если написано <code>std::vector&lt;Args&gt;&amp;&amp;</code>, это тоже не попадает под исключение из правил</li>
</ol>
<ul>
<li>упражнение</li>
</ul>
<p>хотим написать конструктор от произвольного количества строк, причем строки могут быть как lvalue, так и rvalue</p>
<pre><code class="language-cpp">struct S {
    std::vector&lt;std::string&gt; v;

    template&lt;typename... Args&gt;
    S(Args&amp;&amp;... args) {
        static_assert((std::is_convertible_v&lt;Args, std::string&gt; &amp;&amp; ...));
        v.reserve(sizeof...(args));
        (v.push_back(std::forward&lt;Args&gt;(args)), ...);
    }
};
</code></pre>
<h2><a class="header" href="#Правила-вывода-шаблонного-типа-для-обычных-и-универсальных-ссылок" id="Правила-вывода-шаблонного-типа-для-обычных-и-универсальных-ссылок">Правила вывода шаблонного типа для обычных и универсальных ссылок</a></h2>
<p>рассмотрим вот такие функции</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
void f(T x);

template&lt;typename T&gt;
void g(T&amp; x);

template&lt;typename T&gt;
void h(T&amp;&amp; x);
</code></pre>
<p>для f и g всё очевидно, но для универсальных ссылок перестают работать правила вывода типа T</p>
<pre><code class="language-cpp">int x = 0;
f(x); // T = int
g(x); // T = int
h(x); // T = int&amp;

int&amp; y = x;
f(y); // T = int
g(y); // T = int
h(y); // T = int&amp;

int&amp;&amp; z = std::move(x);
f(z); // T = int
g(z); // T = int
h(z); // T = int&amp;
</code></pre>
<p>если функция принимает универсальную ссылку и мы вызываемся от lvalue, на T дополнительно навешивается &amp;</p>
<p>но если вызываемся от rvalue</p>
<pre><code class="language-cpp">h(1); // T = int
h(std::move(x)); // T = int
</code></pre>
<p><strong>правило: если мы вызываемся от lvalue, то T становится равным типу без ссылок с навешенным амперсандом, а если мы вызываемся от rvalue, то T выводится как обычно</strong></p>
<p>это всё работает <strong>только</strong> для случая, когда мы явно не указали тип T</p>
<p>а какой тогда тип имеет сам объект x?</p>
<ul>
<li>reference collapsing rules
<ul>
<li><code>&amp; + &amp;</code> -&gt; <code>&amp;</code></li>
<li><code>&amp;&amp; + &amp;</code> -&gt; <code>&amp;</code></li>
<li><code>&amp; + &amp;&amp;</code> -&gt; <code>&amp;</code></li>
<li><code>&amp;&amp; + &amp;&amp;</code> -&gt; <code>&amp;&amp;</code></li>
</ul>
</li>
</ul>
<p>если в момент вывода типа переменной в шаблоне у нас накладываются амперсанды один на другой, то они преобразуются по такому правилу</p>
<p>для функции h:</p>
<ul>
<li>если мы передаем lvalue, то T = тип с &amp;. на него навешивается еще &amp;&amp;, в итоге по правилу получается <code>T&amp;</code></li>
<li>а если мы передаем rvalue, то T = просто тип. на него навесилось &amp;&amp;, получилось просто <code>T&amp;&amp;</code></li>
</ul>
<p>с помощью этого костыля функции с универсальными ссылками могут принимать как lvalue, так и rvalue и различать эти виды value (подсказка насчёт того, как работает <code>std::forward</code>)</p>
<h1><a class="header" href="#Лекция-41" id="Лекция-41">Лекция 41</a></h1>
<p>повторим: если функция принимает тип вида <code>T&amp;&amp;</code> , где T - это шаблонный параметр данной функции, то есть всего 2 варианта:</p>
<ol>
<li>если мы передаем lvalue, то объект будет иметь тип <code>T&amp;</code></li>
<li>если мы передаем rvalue, то объект будет иметь тип <code>T&amp;&amp;</code></li>
</ol>
<h2><a class="header" href="#Реализация-stdmove-и-stdforward" id="Реализация-stdmove-и-stdforward">Реализация <code>std::move</code> и <code>std::forward</code></a></h2>
<ul>
<li>сначала исправим <a href="lectures/./code/lec36/allocator.cpp">код аллокатора</a> с 36 лекции</li>
</ul>
<pre><code class="language-cpp">template &lt;typename U, typename... Args&gt;
void construct(U* ptr, Args&amp;&amp;... args) {
    new (ptr) U(std::forward&lt;Args&gt;(args)...);
}
</code></pre>
<p>заметим, что при вызове мы явно указываем тип шаблонного параметра Args, в <code>forward</code> правила вывода типа T работать не будут!</p>
<p>здесь args это lvalue независимо от того, передавали мы сюла lvalue или rvalue. но именно <strong>тип Args содержит информацию об исходном value category</strong>. если этот тип с одним амперсандом, то исходно в args попал lvalue. а если с двумя амперсандами, то исходно в args попал rvalue. и именно <strong>благодаря явной передаче этого типа в <code>forward</code>, он сможет определить, какой именно value category был изначально</strong></p>
<ul>
<li>напишем реализацию <a href="https://en.cppreference.com/w/cpp/utility/forward">std::forward</a></li>
</ul>
<p>что нам нужно написать?</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
? forward (? value) {
    return ?;
}
</code></pre>
<p>хотим, чтобы если нам передами lvalue, то мы бы и дальше вернули lvalue. а если нам передами rvalue, то мы бы вернули rvalue <strong>(разделить эти 2 ветки)</strong></p>
<h2><a class="header" href="#Наивная-попытка" id="Наивная-попытка">Наивная попытка</a></h2>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; forward(T&amp;&amp; value) {
    return value;
}
</code></pre>
<p>рассмотрим случаи на примере int</p>
<ol>
<li>lvalue</li>
</ol>
<pre><code class="language-cpp">Args = int&amp;
typeof(args) = int&amp; // reference collapsing в construct

T = int&amp; // явно указали тип шаблонного параметра
typeof(value) = int&amp; // reference collapsing в forward
</code></pre>
<pre><code class="language-cpp">int&amp;&amp;&amp; forward(int&amp;&amp;&amp; value) {
    return value;
}
</code></pre>
<p>reference collapsing -&gt;</p>
<pre><code class="language-cpp">int&amp; forward(int&amp; value) {
    return value;
}
</code></pre>
<p>в <code>construct</code> попало lvalue, <code>forward</code> вызывается от lvalue, вернули lvalue - OK</p>
<ol start="2">
<li>rvalue</li>
</ol>
<pre><code class="language-cpp">Args = int
typeof(args) = int&amp;&amp; // reference collapsing в construct

T = int // явно указали тип шаблонного параметра
typeof(value) = int&amp;&amp;
</code></pre>
<pre><code class="language-cpp">int&amp;&amp; forward(int&amp;&amp; value) {
    return value;
}
</code></pre>
<p>в <code>construct</code> попало rvalue, <code>forward</code> вызывается от lvalue (переменная <code>int&amp;&amp; args</code> - это уже lvalue!) и пытается проинициализировать rvalue ссылку через lvalue - CE</p>
<h2><a class="header" href="#Вторая-попытка" id="Вторая-попытка">Вторая попытка</a></h2>
<p>исправим проблему инициализации rvalue ссылки через lvalue</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; forward(T&amp; value) {
    return value;
}
</code></pre>
<p>но теперь здесь будет та же самая проблема, только при возврате</p>
<pre><code class="language-cpp">int&amp;&amp; forward(int&amp; value) {
    return value;
}
</code></pre>
<p>в <code>construct</code> попало rvalue, <code>forward</code> вызывается от lvalue (переменная <code>int&amp;&amp; args</code> - это уже lvalue!) и <code>int&amp; value</code> нормально инициализируется</p>
<p>но на возврате из функции пытаемся проинициализировать rvalue ссылку <code>int&amp;&amp;</code> через <code>int&amp;</code> - CE</p>
<ul>
<li>исправим и эту проблему, сделаем <code>static_cast</code></li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; forward(T&amp; value) {
    return static_cast&lt;T&amp;&amp;&gt;(value);
}
</code></pre>
<p>но кажется, что этот forward ничем не отличается от move, который мы реализовывали на позапрошлой лекции :)</p>
<p>снова рассмотрим случаи</p>
<ol>
<li>lvalue</li>
</ol>
<pre><code class="language-cpp">Args = int&amp;
typeof(args) = int&amp; // reference collapsing в construct

T = int&amp; // явно указали тип шаблонного параметра
typeof(value) = int&amp; // reference collapsing в forward
</code></pre>
<pre><code class="language-cpp">int&amp;&amp;&amp; forward(int&amp;&amp; value) {
    return static_cast&lt;int&amp;&amp;&amp;&gt;(value);
}
</code></pre>
<p>reference collapsing -&gt;</p>
<pre><code class="language-cpp">int&amp; forward(int&amp; value) { // здесь сработало &amp; + &amp; -&gt; &amp;
    return static_cast&lt;int&amp;&gt;(value);
}
</code></pre>
<p>в <code>construct</code> попало lvalue, <code>forward</code> вызывается от lvalue, вернули lvalue - OK</p>
<ol start="2">
<li>rvalue</li>
</ol>
<pre><code class="language-cpp">Args = int
typeof(args) = int&amp;&amp; // reference collapsing в construct

T = int // явно указали тип шаблонного параметра
typeof(value) = int&amp;&amp;
</code></pre>
<pre><code class="language-cpp">int&amp;&amp; forward(int&amp; value) {
    return static_cast&lt;int&amp;&amp;&gt;(value);
}
</code></pre>
<p>в <code>construct</code> попало rvalue, <code>forward</code> вызывается от lvalue (переменная <code>int&amp;&amp; args</code> - это уже lvalue!) и <code>int&amp; value</code> нормально инициализируется, делаем <code>static_cast</code>, возвращаем rvalue - OK</p>
<p><strong>таким образом этот код благодаря переданному типу T определяет value category исходного выражения (который был передан в <code>construct</code>)</strong></p>
<p>на самом деле, тот <code>move</code>, который мы написали, это <code>forward</code> (хыхы пон)</p>
<h2><a class="header" href="#Правильная-реализация-stdmove" id="Правильная-реализация-stdmove">Правильная реализация <code>std::move</code></a></h2>
<p>поймём, что наша старая реализация <a href="https://en.cppreference.com/w/cpp/utility/move">std::move</a> не совсем правильная</p>
<ul>
<li><strong><code>move</code> не должен возвращать lvalue никогда</strong>!</li>
</ul>
<p>как мы только что выяснили, в нашей старой реализации <code>move</code> возвращает lvalue, если ему в качестве T подсунуть одиночный амперсанд, а мы хотим чтобы <code>move</code> всегда возвращал тип с двумя амперсандами
поймём, что наша старая реализация
<strong>мы не хотим разделять value category исходного выражения (в отличии от <code>forward</code> не хотим разделять 2 ветки), мы хотим всегда вернуть rvalue</strong></p>
<p>это произошло из-за правила reference collapsing, о котором мы раньше не знали. но мы не хотим, чтобы работало reference collapsing, когда мы возвращаем из <code>move</code></p>
<p><a href="https://en.cppreference.com/w/cpp/types/remove_reference">std::remove_reference</a> - снимает все амперсанды с типа</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
std::remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp; value) {
    return static_cast&lt;std::remove_reference_t&lt;T&gt;&amp;&amp;&gt;(value);
}
</code></pre>
<p>мы как бы отключили правило reference collapsing для возвращаемого типа <strong>(слили 2 ветки вместе)</strong> и теперь всегда возвращаем rvalue ссылку</p>
<ul>
<li>теперь поймём, что и принимаемый тип <code>move</code> не такой</li>
</ul>
<pre><code class="language-cpp">template &lt;typename T&gt;
std::remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp; value) {
    return static_cast&lt;std::remove_reference_t&lt;T&gt;&amp;&amp;&gt;(value);
}
</code></pre>
<p>в <code>move</code> можно отдавать, как и lvalue, так и rvalue. и не важно, что мы дали - на выходе всё равно будет rvalue</p>
<p>пример - хотим передать в <code>move</code> результат какой-то функции, которая иногда возвращает lvalue, а иногда rvalue (в зависимости от T)</p>
<pre><code class="language-cpp">move(f&lt;T&gt;(x));
</code></pre>
<h2><a class="header" href="#Правильная-реализация-stdforward" id="Правильная-реализация-stdforward">Правильная реализация <code>std::forward</code></a></h2>
<p>теперь поймём, что и наша реализация <code>forward</code> не совсем правильная</p>
<ul>
<li><strong>хотим, чтобы <code>forward</code> не умел выводить тип шаблонного параметра неявно</strong></li>
</ul>
<p>на самом деле <code>forward</code> выглядит так</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp; value) {
    return static_cast&lt;T&amp;&amp;&gt;(value);
}
</code></pre>
<p>костыль такой - будем принимать не <code>T&amp;</code>, а <code>std::remove_reference_t&lt;T&gt;&amp;</code></p>
<p>компилятор не умеет подбирать T, чтобы <code>std::remove_reference_t&lt;T&gt;</code> соответствовал нужному типу</p>
<p>если бы он умел выводить его неявно, то мы бы могли пользоваться <code>forward</code> неправильно. мы бы могли мувать, когда не надо</p>
<p>если оставить так</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; forward(T&amp; value) {
    return static_cast&lt;T&amp;&amp;&gt;(value);
}
</code></pre>
<p>мы бы могли написать вот так</p>
<pre><code class="language-cpp">std::forward(args);
</code></pre>
<p>тогда компилятор бы за нас вывел шаблонный аргумент, как T = тип без амперснадов. мы бы навесили на него два амперсанда, и получилось бы что <code>forward</code> мувает, хотя не должен</p>
<p>пример - вернемся опять к случаю с lvalue в construct</p>
<pre><code class="language-cpp">Args = int&amp;
typeof(args) = int&amp; // reference collapsing в construct

T = int // вывелось само!!! (и причем по старым правилам вывода)
typeof(value) = int&amp;
</code></pre>
<pre><code class="language-cpp">int&amp;&amp; forward(int&amp; value) {
    return static_cast&lt;int&amp;&amp;&gt;(value);
}
</code></pre>
<p><code>forward</code> возвращает назад rvalue, хотя изначально в <code>construct</code> передали lvalue. это неправильное поведение</p>
<p>поэтому принимаем <code>std::remove_reference_t&lt;T&gt;</code></p>
<ul>
<li><code>forward</code> от rvalue иногда тоже имеет смысл</li>
</ul>
<p>в <code>forward</code> тоже можно отдавать, как и lvalue, так и rvalue</p>
<p>пример такой же - хотим форвардить не напрямую аргументы, а результат какой-то функции, которая иногда возвращает lvalue, а иногда rvalue (в зависимости от T)</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp; value) {
    return static_cast&lt;T&amp;&amp;&gt;(value);
}

void foo(const std::string&amp;) {}
void foo(std::string&amp;&amp;) {}

struct Arg {
    std::string s = &quot;abc&quot;;
    std::string&amp; get() &amp;  { return s; }
    std::string  get() &amp;&amp; { return s; }
};

template&lt;class T&gt;
void wrapper(T&amp;&amp; arg) {
    using typeOfStr = decltype(::forward&lt;T&gt;(arg).get()); // выводим тип строчки (пока не знаем, что такое decltype)
    foo(::forward&lt;typeOfStr&gt;(::forward&lt;T&gt;(arg).get()));
}

int main() {
    Arg arg;
    wrapper(arg); // OK
    wrapper(Arg{}); // CE
}
</code></pre>
<p>пусть мы хотим вызвать метод объекта (и именно для его настоящего value catergory), а результат этого ещё раз зафорвардить. причем метод возвращает rvalue строку, если изначально объект был rvalue. и lvalue строку, если изначально объект был lvalue</p>
<p>тогда внешний вызов <code>forward</code> для rvalue даже не скомпилируется, наша версия принимает только lvalue</p>
<ul>
<li>поэтому на самом деле у <code>forward</code> есть перегрузка</li>
</ul>
<p>здесь не получится сделать одну версию, как с <code>move</code>, потому что <strong><code>std::remove_reference_t&lt;T&gt;&amp;&amp;</code> - не универсальная ссылка</strong></p>
<p>нужно явно сделать вторую версию для rvalue</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp; value) {
    return static_cast&lt;T&amp;&amp;&gt;(value);
}

template &lt;typename T&gt;
T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp;&amp; value) {
    static_assert(!std::is_lvalue_reference_v&lt;T&gt;);
    return static_cast&lt;T&amp;&amp;&gt;(value);
}
</code></pre>
<p>вторая версия форвардит rvalue как rvalue и <strong>запрещает форвардить rvalue как lvalue</strong></p>
<p><a href="https://en.cppreference.com/w/cpp/types/is_lvalue_reference">std::is_lvalue_reference</a> - проверяет, что тип является обычной ссылкой (<code>T&amp;</code>)</p>
<p>если не написать <code>static_assert</code>, то можно будет руками вызывать <code>forward&lt;int&amp;&gt;(5)</code></p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp;&amp; value) {
    return static_cast&lt;T&amp;&amp;&gt;(value);
}
</code></pre>
<pre><code class="language-cpp">T = int&amp; // lvalue, заданный руками
</code></pre>
<pre><code class="language-cpp">int&amp;&amp;&amp; forward(int&amp;&amp; value) {
    return static_cast&lt;int&amp;&amp;&amp;&gt;(value);
}
</code></pre>
<p>reference collapsing -&gt;</p>
<pre><code class="language-cpp">int&amp; forward(int&amp;&amp; value) {
    return static_cast&lt;int&amp;&gt;(value);
}
</code></pre>
<p>сфорвардили rvalue как lvalue</p>
<p>такое может привести к висящим ссылкам. например, если эту ссылку <code>int&amp;</code> потом куда-то сохранить, а временный объект уничтожится. поэтому запрещаем такое в compile time</p>
<h2><a class="header" href="#Итоговый-код-stdmove-и-stdforward" id="Итоговый-код-stdmove-и-stdforward">Итоговый код <code>std::move</code> и <code>std::forward</code></a></h2>
<pre><code class="language-cpp">template &lt;typename T&gt;
std::remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp; value) noexcept {
    return static_cast&lt;std::remove_reference_t&lt;T&gt;&amp;&amp;&gt;(value);
}

template &lt;typename T&gt;
T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp; value) noexcept {
    return static_cast&lt;T&amp;&amp;&gt;(value);
}

template &lt;typename T&gt;
T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp;&amp; value) noexcept {
    static_assert(!std::is_lvalue_reference_v&lt;T&gt;);
    return static_cast&lt;T&amp;&amp;&gt;(value);
}
</code></pre>
<p>навесили <code>noexcept</code></p>
<h2><a class="header" href="#Исправление-push_back-с-учётом-move-семантики" id="Исправление-push_back-с-учётом-move-семантики">Исправление <code>push_back</code> с учётом move семантики</a></h2>
<p>исправим <a href="lectures/./code/lec36/vector.cpp">код вектора</a> с 36 лекции</p>
<p>теперь мы можем написать так</p>
<pre><code class="language-cpp">void push_back(const T&amp; value) {
    if (sz_ == cap_) {
        reserve(cap_ &gt; 0 ? cap_ * 2 : 1);
    }
    AllocTraits::construct(alloc_, arr_ + sz_, value);
    ++sz_;
}

void push_back(T&amp;&amp; value) {
    if (sz_ == cap_) {
        reserve(cap_ &gt; 0 ? cap_ * 2 : 1);
    }
    AllocTraits::construct(alloc_, arr_ + sz_, std::move(value));
    ++sz_;
}
</code></pre>
<p>для rvalue - просто муваем временный объект сразу в новую память. то, чего изначально и хотели</p>
<p>на самом деле обе функции <code>push_back</code> выражаются через <code>emplace_back</code></p>
<pre><code class="language-cpp">void push_back(const T&amp; value) {
    emplace_back(value);
}

void push_back(T&amp;&amp; value) {
    emplace_back(std::move(value));
}

template &lt;typename... Args&gt;
void emplace_back(Args&amp;&amp;... args) {
    if (sz_ == cap_) {
        reserve(cap_ &gt; 0 ? cap_ * 2 : 1);
    }
    AllocTraits::construct(alloc_, arr_ + sz_, std::forward&lt;Args&gt;(args)...);
    ++sz_;
}
</code></pre>
<h2><a class="header" href="#Проблема-реаллокации" id="Проблема-реаллокации">Проблема реаллокации</a></h2>
<p>в методе <code>reserve</code> мы на новом массиве создаём объекты из старых массивов</p>
<pre><code class="language-cpp">for (; index &lt; sz_; ++index) {
    AllocTraits::construct(alloc_, newarr + index, arr_[index]);
}
</code></pre>
<p>сейчас это работает с копированием. для больших объектов это долго</p>
<p>применим <code>std::move</code></p>
<pre><code class="language-cpp">for (; index &lt; sz_; ++index) {
    AllocTraits::construct(alloc_, newarr + index, std::move(arr_[index]));
}
</code></pre>
<p>но как быть в случае исключений? - пропало exception safety</p>
<p>мы начали мувать объекты и вылетело исключение<br />
<img src="lectures/img/45.png" alt="alt text" /><br />
и мы не можем начать просто мувать обратно - вдруг снова вылетит исключение?</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/utility/move_if_noexcept">std::move_if_noexcept</a> - если move конструктор <code>noexcept</code> она возвращает rvalue, иначе lvalue</li>
</ul>
<p>если move конструктор <code>noexcept</code>, то спокойно муваем. иначе копируем</p>
<p>в таком случае действия в <code>catch</code> по прежнему верные (для мув версии просто здесь просто никогда не будет исключений)</p>
<pre><code class="language-cpp">try {
    for (; index &lt; sz_; ++index) {
        AllocTraits::construct(alloc_, newarr + index, std::move_if_noexcept(arr_[index]));
    }
} catch (...) {
    for (size_t oldindex = 0; oldindex &lt; index; ++oldindex) {
        AllocTraits::destroy(alloc_, newarr + oldindex);
    }
    AllocTraits::deallocate(alloc_, newarr, newcap);
    throw;
}
</code></pre>
<p><strong>вывод: надо помечать move конструктор <code>noexcept</code>!</strong></p>
<h2><a class="header" href="#Реализация-a-hrefhttpsencppreferencecomwcpputilitymove_if_noexceptstdmove_if_noexcepta" id="Реализация-a-hrefhttpsencppreferencecomwcpputilitymove_if_noexceptstdmove_if_noexcepta">Реализация <a href="https://en.cppreference.com/w/cpp/utility/move_if_noexcept">std::move_if_noexcept</a></a></h2>
<p><a href="https://en.cppreference.com/w/cpp/types/is_move_constructible">std::is_nothrow_move_constructible</a> - проверяет, является ли move конструктор <code>noexcept</code></p>
<p><a href="https://en.cppreference.com/w/cpp/types/is_copy_constructible">std::is_copy_constructible</a> - является ли копируемым</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
typename std::conditional_t&lt;
    !std::is_nothrow_move_constructible_v&lt;T&gt; || !std::is_copy_constructible_v&lt;T&gt;,
    const T&amp;,
    T&amp;&amp;
&gt; move_if_noexcept(T&amp; value) noexcept {
    return move(value);
}
</code></pre>
<p>зачем нужно второе условие?</p>
<p>допустим, что мы хотим сделать вектор из типов, которые нельзя копировать, но можно мувать. и при этом move конструктор не помечен <code>noexcept</code></p>
<p>тогда вектор отказывается от exception safety. мы всё равно муваем этот тип, просто делаем это небезопасно</p>
<p>в <code>move_if_noexcept</code> не хотим отдавать rvalue, поэтому здесь принимаем просто <code>T&amp;</code></p>
<h2><a class="header" href="#push_back-в-вектор-элемента-того-же-вектора" id="push_back-в-вектор-элемента-того-же-вектора"><code>push_back</code> в вектор элемента того же вектора</a></h2>
<pre><code class="language-cpp">std::vector&lt;std::string&gt; v(5, &quot;abc&quot;);
v.push_back(v[3]);
</code></pre>
<p>приняли объект по ссылке. и до того, как мы его куда-то положили мы сделали реаллокацию (вызвали деструкторы, освободили памяли) - получили битую ссылку<br />
<img src="lectures/img/46.png" alt="alt text" /></p>
<p>решение: сначала положим элемент в новую память, а только потом будем перекладывать старые. <code>v[3]</code> - lvalue. поэтому он просто скопируется</p>
<h2><a class="header" href="#Переосмысление-принятия-параметров-в-функцию" id="Переосмысление-принятия-параметров-в-функцию">Переосмысление принятия параметров в функцию</a></h2>
<p>почему бы нам не перестать принимать параметры по ссылке?</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void f(T x) {
    //...
}
</code></pre>
<p>такое имеет смысл, если мы дальше будем куда-то сохранять или передавать x</p>
<p>если мы принимаем lvalue, то оно скопируется и мы его сможем менять. а если мы принимаем rvalue, то оно сразу мувнется на входе в функцию -&gt; дальше можно всегда мувать этот объект</p>
<p>например так можно написать <code>push_back</code></p>
<pre><code class="language-cpp">void push_back(T value) {
    //...
}
</code></pre>
<p>если все объекты поддерживают move семантику, вместо 2 перегрузок можно написать 1 версию, а дальше всегда мувать этот объект value. проблема только, если объект не поддерживает move семантику</p>
<p>в stl <code>push_back</code> всё таки имеет 2 версии. это сделано для обратной совместимости. и потому что не все типы поддерживают move семантику</p>
<p><code>push_back</code> не должен обязывать нас соблюдать move семантику. хотим уметь пользоваться им и по старинке</p>
<p>конечно, если мы не хотим никуда передавать или менять этот объект, всё это не имеет смысла</p>
<p><a href="lectures/./code/lec41/allocator.cpp">итоговый код аллокатора</a><br />
<a href="lectures/./code/lec41/move_forward.cpp">итоговый код move и forward</a><br />
<a href="lectures/./code/lec41/vector.cpp">итоговый код вектора</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
